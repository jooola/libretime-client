/* tslint:disable */
/* eslint-disable */
/**
 * LibreTime API
 * Radio Broadcast & Automation Platform
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface CeleryTask
 */
export interface CeleryTask {
    /**
     * 
     * @type {string}
     * @memberof CeleryTask
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof CeleryTask
     */
    'task_id': string;
    /**
     * 
     * @type {string}
     * @memberof CeleryTask
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CeleryTask
     */
    'dispatch_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CeleryTask
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof CeleryTask
     */
    'track_reference': string;
}
/**
 * 
 * @export
 * @interface CloudFile
 */
export interface CloudFile {
    /**
     * 
     * @type {string}
     * @memberof CloudFile
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof CloudFile
     */
    'storage_backend': string;
    /**
     * 
     * @type {string}
     * @memberof CloudFile
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof CloudFile
     */
    'filename'?: string | null;
}
/**
 * 
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof Country
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ImportedPodcast
 */
export interface ImportedPodcast {
    /**
     * 
     * @type {string}
     * @memberof ImportedPodcast
     */
    'item_url': string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportedPodcast
     */
    'auto_ingest': boolean;
    /**
     * 
     * @type {string}
     * @memberof ImportedPodcast
     */
    'auto_ingest_timestamp'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ImportedPodcast
     */
    'album_override': boolean;
    /**
     * 
     * @type {string}
     * @memberof ImportedPodcast
     */
    'podcast': string;
}
/**
 * 
 * @export
 * @interface ListenerCount
 */
export interface ListenerCount {
    /**
     * 
     * @type {string}
     * @memberof ListenerCount
     */
    'item_url': string;
    /**
     * 
     * @type {number}
     * @memberof ListenerCount
     */
    'listener_count': number;
    /**
     * 
     * @type {string}
     * @memberof ListenerCount
     */
    'timestamp': string;
    /**
     * 
     * @type {string}
     * @memberof ListenerCount
     */
    'mount_name': string;
}
/**
 * 
 * @export
 * @interface LiveLog
 */
export interface LiveLog {
    /**
     * 
     * @type {string}
     * @memberof LiveLog
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof LiveLog
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof LiveLog
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof LiveLog
     */
    'end_time'?: string | null;
}
/**
 * 
 * @export
 * @interface LoginAttempt
 */
export interface LoginAttempt {
    /**
     * 
     * @type {string}
     * @memberof LoginAttempt
     */
    'item_url': string;
    /**
     * 
     * @type {number}
     * @memberof LoginAttempt
     */
    'attempts'?: number | null;
}
/**
 * 
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'item_url': string;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'mime': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'ftype': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'filepath'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'import_status': number;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'currently_accessing': number;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'mtime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'utime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'lptime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'md5'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'track_title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'artist_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'bit_rate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'sample_rate'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'format'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'length'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'album_title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'genre'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'comments'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'year'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'track_number'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'channels'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'bpm'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'rating'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'encoded_by'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'disc_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'mood'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'composer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'encoder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'checksum'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'lyrics'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'orchestra'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'conductor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'lyricist'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'original_lyricist'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'radio_station_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'info_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'artist_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'audio_source_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'radio_station_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'buy_this_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'isrc_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'catalog_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'original_artist'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'copyright'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'report_datetime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'report_location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'report_organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'subject'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'contributor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'language'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ModelFile
     */
    'file_exists'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'replay_gain'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'cuein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'cueout'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ModelFile
     */
    'silan_check'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ModelFile
     */
    'hidden'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ModelFile
     */
    'is_scheduled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ModelFile
     */
    'is_playlist'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ModelFile
     */
    'filesize': number;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'artwork'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'track_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'directory'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'edited_by'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ModelFile
     */
    'owner'?: string | null;
}
/**
 * 
 * @export
 * @interface MountName
 */
export interface MountName {
    /**
     * 
     * @type {string}
     * @memberof MountName
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof MountName
     */
    'mount_name': string;
}
/**
 * 
 * @export
 * @interface MusicDir
 */
export interface MusicDir {
    /**
     * 
     * @type {string}
     * @memberof MusicDir
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof MusicDir
     */
    'directory'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MusicDir
     */
    'type'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MusicDir
     */
    'exists'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof MusicDir
     */
    'watched'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PatchedCeleryTask
 */
export interface PatchedCeleryTask {
    /**
     * 
     * @type {string}
     * @memberof PatchedCeleryTask
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCeleryTask
     */
    'task_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCeleryTask
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCeleryTask
     */
    'dispatch_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCeleryTask
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCeleryTask
     */
    'track_reference'?: string;
}
/**
 * 
 * @export
 * @interface PatchedCloudFile
 */
export interface PatchedCloudFile {
    /**
     * 
     * @type {string}
     * @memberof PatchedCloudFile
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCloudFile
     */
    'storage_backend'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCloudFile
     */
    'resource_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCloudFile
     */
    'filename'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedCountry
 */
export interface PatchedCountry {
    /**
     * 
     * @type {string}
     * @memberof PatchedCountry
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCountry
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PatchedFile
 */
export interface PatchedFile {
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'item_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedFile
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'mime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'ftype'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'filepath'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFile
     */
    'import_status'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedFile
     */
    'currently_accessing'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'mtime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'utime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'lptime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'md5'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'track_title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'artist_name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFile
     */
    'bit_rate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFile
     */
    'sample_rate'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'format'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'length'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'album_title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'genre'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'comments'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'year'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFile
     */
    'track_number'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFile
     */
    'channels'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFile
     */
    'bpm'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'rating'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'encoded_by'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'disc_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'mood'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'composer'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'encoder'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'checksum'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'lyrics'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'orchestra'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'conductor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'lyricist'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'original_lyricist'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'radio_station_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'info_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'artist_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'audio_source_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'radio_station_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'buy_this_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'isrc_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'catalog_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'original_artist'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'copyright'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'report_datetime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'report_location'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'report_organization'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'subject'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'contributor'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'language'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFile
     */
    'file_exists'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'replay_gain'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'cuein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'cueout'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFile
     */
    'silan_check'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFile
     */
    'hidden'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFile
     */
    'is_scheduled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFile
     */
    'is_playlist'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFile
     */
    'filesize'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'artwork'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'track_type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'directory'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'edited_by'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFile
     */
    'owner'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedImportedPodcast
 */
export interface PatchedImportedPodcast {
    /**
     * 
     * @type {string}
     * @memberof PatchedImportedPodcast
     */
    'item_url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedImportedPodcast
     */
    'auto_ingest'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedImportedPodcast
     */
    'auto_ingest_timestamp'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedImportedPodcast
     */
    'album_override'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedImportedPodcast
     */
    'podcast'?: string;
}
/**
 * 
 * @export
 * @interface PatchedListenerCount
 */
export interface PatchedListenerCount {
    /**
     * 
     * @type {string}
     * @memberof PatchedListenerCount
     */
    'item_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedListenerCount
     */
    'listener_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedListenerCount
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedListenerCount
     */
    'mount_name'?: string;
}
/**
 * 
 * @export
 * @interface PatchedLiveLog
 */
export interface PatchedLiveLog {
    /**
     * 
     * @type {string}
     * @memberof PatchedLiveLog
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedLiveLog
     */
    'state'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedLiveLog
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedLiveLog
     */
    'end_time'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedLoginAttempt
 */
export interface PatchedLoginAttempt {
    /**
     * 
     * @type {string}
     * @memberof PatchedLoginAttempt
     */
    'item_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedLoginAttempt
     */
    'attempts'?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedMountName
 */
export interface PatchedMountName {
    /**
     * 
     * @type {string}
     * @memberof PatchedMountName
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMountName
     */
    'mount_name'?: string;
}
/**
 * 
 * @export
 * @interface PatchedMusicDir
 */
export interface PatchedMusicDir {
    /**
     * 
     * @type {string}
     * @memberof PatchedMusicDir
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMusicDir
     */
    'directory'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedMusicDir
     */
    'type'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMusicDir
     */
    'exists'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMusicDir
     */
    'watched'?: boolean | null;
}
/**
 * 
 * @export
 * @interface PatchedPlaylist
 */
export interface PatchedPlaylist {
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylist
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylist
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylist
     */
    'mtime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylist
     */
    'utime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylist
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylist
     */
    'length'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylist
     */
    'creator'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedPlaylistContent
 */
export interface PatchedPlaylistContent {
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylistContent
     */
    'item_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlaylistContent
     */
    'stream_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlaylistContent
     */
    'type'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlaylistContent
     */
    'position'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlaylistContent
     */
    'trackoffset'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylistContent
     */
    'cliplength'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylistContent
     */
    'cuein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylistContent
     */
    'cueout'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylistContent
     */
    'fadein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylistContent
     */
    'fadeout'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylistContent
     */
    'playlist'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylistContent
     */
    'file'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlaylistContent
     */
    'block'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedPlayoutHistory
 */
export interface PatchedPlayoutHistory {
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistory
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistory
     */
    'starts'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistory
     */
    'ends'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistory
     */
    'file'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistory
     */
    'instance'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedPlayoutHistoryMetadata
 */
export interface PatchedPlayoutHistoryMetadata {
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryMetadata
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryMetadata
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryMetadata
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryMetadata
     */
    'history'?: string;
}
/**
 * 
 * @export
 * @interface PatchedPlayoutHistoryTemplate
 */
export interface PatchedPlayoutHistoryTemplate {
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryTemplate
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryTemplate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryTemplate
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PatchedPlayoutHistoryTemplateField
 */
export interface PatchedPlayoutHistoryTemplateField {
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryTemplateField
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryTemplateField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryTemplateField
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryTemplateField
     */
    'type'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedPlayoutHistoryTemplateField
     */
    'is_file_md'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedPlayoutHistoryTemplateField
     */
    'position'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPlayoutHistoryTemplateField
     */
    'template'?: string;
}
/**
 * 
 * @export
 * @interface PatchedPodcast
 */
export interface PatchedPodcast {
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'creator'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'copyright'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'itunes_author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'itunes_keywords'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'itunes_summary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'itunes_subtitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'itunes_category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'itunes_explicit'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcast
     */
    'owner'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedPodcastEpisode
 */
export interface PatchedPodcastEpisode {
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcastEpisode
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcastEpisode
     */
    'publication_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcastEpisode
     */
    'download_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcastEpisode
     */
    'episode_guid'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcastEpisode
     */
    'episode_title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcastEpisode
     */
    'episode_description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcastEpisode
     */
    'file'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPodcastEpisode
     */
    'podcast'?: string;
}
/**
 * 
 * @export
 * @interface PatchedPreference
 */
export interface PatchedPreference {
    /**
     * 
     * @type {string}
     * @memberof PatchedPreference
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPreference
     */
    'keystr'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPreference
     */
    'valstr'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPreference
     */
    'subjid'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedSchedule
 */
export interface PatchedSchedule {
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'item_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSchedule
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'starts'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'ends'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'file'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSchedule
     */
    'file_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'stream'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSchedule
     */
    'stream_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'clip_length'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'fade_in'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'fade_out'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'cue_in'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'cue_out'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSchedule
     */
    'media_item_played'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSchedule
     */
    'instance'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSchedule
     */
    'instance_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSchedule
     */
    'playout_status'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSchedule
     */
    'broadcasted'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSchedule
     */
    'position'?: number;
}
/**
 * 
 * @export
 * @interface PatchedServiceRegister
 */
export interface PatchedServiceRegister {
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceRegister
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedServiceRegister
     */
    'ip'?: string;
}
/**
 * 
 * @export
 * @interface PatchedSession
 */
export interface PatchedSession {
    /**
     * 
     * @type {string}
     * @memberof PatchedSession
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSession
     */
    'login'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSession
     */
    'ts'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSession
     */
    'userid'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedShow
 */
export interface PatchedShow {
    /**
     * 
     * @type {string}
     * @memberof PatchedShow
     */
    'item_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedShow
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedShow
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShow
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShow
     */
    'genre'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShow
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShow
     */
    'color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShow
     */
    'background_color'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedShow
     */
    'linked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedShow
     */
    'is_linkable'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedShow
     */
    'image_path'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedShow
     */
    'has_autoplaylist'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedShow
     */
    'autoplaylist_repeat'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedShow
     */
    'autoplaylist'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedShowDays
 */
export interface PatchedShowDays {
    /**
     * 
     * @type {string}
     * @memberof PatchedShowDays
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowDays
     */
    'first_show'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowDays
     */
    'last_show'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowDays
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowDays
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowDays
     */
    'duration'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedShowDays
     */
    'day'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShowDays
     */
    'repeat_type'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowDays
     */
    'next_pop_date'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShowDays
     */
    'record'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowDays
     */
    'show'?: string;
}
/**
 * 
 * @export
 * @interface PatchedShowHost
 */
export interface PatchedShowHost {
    /**
     * 
     * @type {string}
     * @memberof PatchedShowHost
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowHost
     */
    'show'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowHost
     */
    'subjs'?: string;
}
/**
 * 
 * @export
 * @interface PatchedShowInstance
 */
export interface PatchedShowInstance {
    /**
     * 
     * @type {string}
     * @memberof PatchedShowInstance
     */
    'item_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedShowInstance
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowInstance
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowInstance
     */
    'starts'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowInstance
     */
    'ends'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedShowInstance
     */
    'record'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShowInstance
     */
    'rebroadcast'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowInstance
     */
    'time_filled'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowInstance
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowInstance
     */
    'last_scheduled'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedShowInstance
     */
    'modified_instance'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedShowInstance
     */
    'autoplaylist_built'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowInstance
     */
    'show'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedShowInstance
     */
    'show_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowInstance
     */
    'instance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowInstance
     */
    'file'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShowInstance
     */
    'file_id'?: number;
}
/**
 * 
 * @export
 * @interface PatchedShowRebroadcast
 */
export interface PatchedShowRebroadcast {
    /**
     * 
     * @type {string}
     * @memberof PatchedShowRebroadcast
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowRebroadcast
     */
    'day_offset'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowRebroadcast
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShowRebroadcast
     */
    'show'?: string;
}
/**
 * 
 * @export
 * @interface PatchedSmartBlock
 */
export interface PatchedSmartBlock {
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlock
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlock
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlock
     */
    'mtime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlock
     */
    'utime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlock
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlock
     */
    'length'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlock
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlock
     */
    'creator'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedSmartBlockContent
 */
export interface PatchedSmartBlockContent {
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockContent
     */
    'item_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSmartBlockContent
     */
    'position'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSmartBlockContent
     */
    'trackoffset'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockContent
     */
    'cliplength'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockContent
     */
    'cuein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockContent
     */
    'cueout'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockContent
     */
    'fadein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockContent
     */
    'fadeout'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockContent
     */
    'block'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockContent
     */
    'file'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedSmartBlockCriteria
 */
export interface PatchedSmartBlockCriteria {
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockCriteria
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockCriteria
     */
    'criteria'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockCriteria
     */
    'modifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockCriteria
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockCriteria
     */
    'extra'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSmartBlockCriteria
     */
    'criteriagroup'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSmartBlockCriteria
     */
    'block'?: string;
}
/**
 * 
 * @export
 * @interface PatchedStationPodcast
 */
export interface PatchedStationPodcast {
    /**
     * 
     * @type {string}
     * @memberof PatchedStationPodcast
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStationPodcast
     */
    'podcast'?: string;
}
/**
 * 
 * @export
 * @interface PatchedStreamSetting
 */
export interface PatchedStreamSetting {
    /**
     * 
     * @type {string}
     * @memberof PatchedStreamSetting
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStreamSetting
     */
    'value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStreamSetting
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface PatchedThirdPartyTrackReference
 */
export interface PatchedThirdPartyTrackReference {
    /**
     * 
     * @type {string}
     * @memberof PatchedThirdPartyTrackReference
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedThirdPartyTrackReference
     */
    'service'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedThirdPartyTrackReference
     */
    'foreign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedThirdPartyTrackReference
     */
    'upload_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedThirdPartyTrackReference
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedThirdPartyTrackReference
     */
    'file'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedTimestamp
 */
export interface PatchedTimestamp {
    /**
     * 
     * @type {string}
     * @memberof PatchedTimestamp
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTimestamp
     */
    'timestamp'?: string;
}
/**
 * 
 * @export
 * @interface PatchedTrackType
 */
export interface PatchedTrackType {
    /**
     * 
     * @type {string}
     * @memberof PatchedTrackType
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTrackType
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTrackType
     */
    'type_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedTrackType
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedTrackType
     */
    'visibility'?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedUser
 */
export interface PatchedUser {
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'username'?: string;
    /**
     * 
     * @type {TypeEnum}
     * @memberof PatchedUser
     */
    'type'?: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'lastfail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'skype_contact'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'jabber_contact'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'cell_phone'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUser
     */
    'login_attempts'?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedUserToken
 */
export interface PatchedUserToken {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserToken
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserToken
     */
    'action'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserToken
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserToken
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserToken
     */
    'user'?: string;
}
/**
 * 
 * @export
 * @interface PatchedWebstream
 */
export interface PatchedWebstream {
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstream
     */
    'item_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedWebstream
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstream
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstream
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstream
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstream
     */
    'length'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedWebstream
     */
    'creator_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstream
     */
    'mtime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstream
     */
    'utime'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstream
     */
    'lptime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstream
     */
    'mime'?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedWebstreamMetadata
 */
export interface PatchedWebstreamMetadata {
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstreamMetadata
     */
    'item_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstreamMetadata
     */
    'start_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstreamMetadata
     */
    'liquidsoap_data'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedWebstreamMetadata
     */
    'instance'?: string;
}
/**
 * 
 * @export
 * @interface Playlist
 */
export interface Playlist {
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'mtime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'utime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'length'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Playlist
     */
    'creator'?: string | null;
}
/**
 * 
 * @export
 * @interface PlaylistContent
 */
export interface PlaylistContent {
    /**
     * 
     * @type {string}
     * @memberof PlaylistContent
     */
    'item_url': string;
    /**
     * 
     * @type {number}
     * @memberof PlaylistContent
     */
    'stream_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaylistContent
     */
    'type': number;
    /**
     * 
     * @type {number}
     * @memberof PlaylistContent
     */
    'position'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlaylistContent
     */
    'trackoffset': number;
    /**
     * 
     * @type {string}
     * @memberof PlaylistContent
     */
    'cliplength'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaylistContent
     */
    'cuein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaylistContent
     */
    'cueout'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaylistContent
     */
    'fadein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaylistContent
     */
    'fadeout'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaylistContent
     */
    'playlist'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaylistContent
     */
    'file'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlaylistContent
     */
    'block'?: string | null;
}
/**
 * 
 * @export
 * @interface PlayoutHistory
 */
export interface PlayoutHistory {
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistory
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistory
     */
    'starts': string;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistory
     */
    'ends'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistory
     */
    'file'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistory
     */
    'instance'?: string | null;
}
/**
 * 
 * @export
 * @interface PlayoutHistoryMetadata
 */
export interface PlayoutHistoryMetadata {
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryMetadata
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryMetadata
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryMetadata
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryMetadata
     */
    'history': string;
}
/**
 * 
 * @export
 * @interface PlayoutHistoryTemplate
 */
export interface PlayoutHistoryTemplate {
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryTemplate
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryTemplate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryTemplate
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface PlayoutHistoryTemplateField
 */
export interface PlayoutHistoryTemplateField {
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryTemplateField
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryTemplateField
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryTemplateField
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryTemplateField
     */
    'type': string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayoutHistoryTemplateField
     */
    'is_file_md': boolean;
    /**
     * 
     * @type {number}
     * @memberof PlayoutHistoryTemplateField
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof PlayoutHistoryTemplateField
     */
    'template': string;
}
/**
 * 
 * @export
 * @interface Podcast
 */
export interface Podcast {
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'creator'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'copyright'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'itunes_author'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'itunes_keywords'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'itunes_summary'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'itunes_subtitle'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'itunes_category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'itunes_explicit'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Podcast
     */
    'owner'?: string | null;
}
/**
 * 
 * @export
 * @interface PodcastEpisode
 */
export interface PodcastEpisode {
    /**
     * 
     * @type {string}
     * @memberof PodcastEpisode
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof PodcastEpisode
     */
    'publication_date': string;
    /**
     * 
     * @type {string}
     * @memberof PodcastEpisode
     */
    'download_url': string;
    /**
     * 
     * @type {string}
     * @memberof PodcastEpisode
     */
    'episode_guid': string;
    /**
     * 
     * @type {string}
     * @memberof PodcastEpisode
     */
    'episode_title': string;
    /**
     * 
     * @type {string}
     * @memberof PodcastEpisode
     */
    'episode_description': string;
    /**
     * 
     * @type {string}
     * @memberof PodcastEpisode
     */
    'file'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PodcastEpisode
     */
    'podcast': string;
}
/**
 * 
 * @export
 * @interface Preference
 */
export interface Preference {
    /**
     * 
     * @type {string}
     * @memberof Preference
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof Preference
     */
    'keystr': string | null;
    /**
     * 
     * @type {string}
     * @memberof Preference
     */
    'valstr'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Preference
     */
    'subjid': string | null;
}
/**
 * 
 * @export
 * @interface Schedule
 */
export interface Schedule {
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'item_url': string;
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'starts': string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'ends': string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'file'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    'file_id': number;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'stream'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    'stream_id': number;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'clip_length'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'fade_in'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'fade_out'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'cue_in': string;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'cue_out': string;
    /**
     * 
     * @type {boolean}
     * @memberof Schedule
     */
    'media_item_played'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof Schedule
     */
    'instance': string;
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    'instance_id': number;
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    'playout_status': number;
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    'broadcasted': number;
    /**
     * 
     * @type {number}
     * @memberof Schedule
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface ServiceRegister
 */
export interface ServiceRegister {
    /**
     * 
     * @type {string}
     * @memberof ServiceRegister
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof ServiceRegister
     */
    'ip': string;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'login'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'ts'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'userid'?: string | null;
}
/**
 * 
 * @export
 * @interface Show
 */
export interface Show {
    /**
     * 
     * @type {string}
     * @memberof Show
     */
    'item_url': string;
    /**
     * 
     * @type {number}
     * @memberof Show
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Show
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Show
     */
    'url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Show
     */
    'genre'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Show
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Show
     */
    'color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Show
     */
    'background_color'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Show
     */
    'linked': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Show
     */
    'is_linkable': boolean;
    /**
     * 
     * @type {string}
     * @memberof Show
     */
    'image_path'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Show
     */
    'has_autoplaylist': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Show
     */
    'autoplaylist_repeat': boolean;
    /**
     * 
     * @type {string}
     * @memberof Show
     */
    'autoplaylist'?: string | null;
}
/**
 * 
 * @export
 * @interface ShowDays
 */
export interface ShowDays {
    /**
     * 
     * @type {string}
     * @memberof ShowDays
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof ShowDays
     */
    'first_show': string;
    /**
     * 
     * @type {string}
     * @memberof ShowDays
     */
    'last_show'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShowDays
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ShowDays
     */
    'timezone': string;
    /**
     * 
     * @type {string}
     * @memberof ShowDays
     */
    'duration': string;
    /**
     * 
     * @type {number}
     * @memberof ShowDays
     */
    'day'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShowDays
     */
    'repeat_type': number;
    /**
     * 
     * @type {string}
     * @memberof ShowDays
     */
    'next_pop_date'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ShowDays
     */
    'record'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ShowDays
     */
    'show': string;
}
/**
 * 
 * @export
 * @interface ShowHost
 */
export interface ShowHost {
    /**
     * 
     * @type {string}
     * @memberof ShowHost
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof ShowHost
     */
    'show': string;
    /**
     * 
     * @type {string}
     * @memberof ShowHost
     */
    'subjs': string;
}
/**
 * 
 * @export
 * @interface ShowInstance
 */
export interface ShowInstance {
    /**
     * 
     * @type {string}
     * @memberof ShowInstance
     */
    'item_url': string;
    /**
     * 
     * @type {number}
     * @memberof ShowInstance
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof ShowInstance
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShowInstance
     */
    'starts': string;
    /**
     * 
     * @type {string}
     * @memberof ShowInstance
     */
    'ends': string;
    /**
     * 
     * @type {number}
     * @memberof ShowInstance
     */
    'record'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShowInstance
     */
    'rebroadcast'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ShowInstance
     */
    'time_filled'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShowInstance
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof ShowInstance
     */
    'last_scheduled'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ShowInstance
     */
    'modified_instance': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShowInstance
     */
    'autoplaylist_built': boolean;
    /**
     * 
     * @type {string}
     * @memberof ShowInstance
     */
    'show': string;
    /**
     * 
     * @type {number}
     * @memberof ShowInstance
     */
    'show_id': number;
    /**
     * 
     * @type {string}
     * @memberof ShowInstance
     */
    'instance'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShowInstance
     */
    'file'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ShowInstance
     */
    'file_id': number;
}
/**
 * 
 * @export
 * @interface ShowRebroadcast
 */
export interface ShowRebroadcast {
    /**
     * 
     * @type {string}
     * @memberof ShowRebroadcast
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof ShowRebroadcast
     */
    'day_offset': string;
    /**
     * 
     * @type {string}
     * @memberof ShowRebroadcast
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof ShowRebroadcast
     */
    'show': string;
}
/**
 * 
 * @export
 * @interface SmartBlock
 */
export interface SmartBlock {
    /**
     * 
     * @type {string}
     * @memberof SmartBlock
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof SmartBlock
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SmartBlock
     */
    'mtime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlock
     */
    'utime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlock
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlock
     */
    'length'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlock
     */
    'type'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlock
     */
    'creator'?: string | null;
}
/**
 * 
 * @export
 * @interface SmartBlockContent
 */
export interface SmartBlockContent {
    /**
     * 
     * @type {string}
     * @memberof SmartBlockContent
     */
    'item_url': string;
    /**
     * 
     * @type {number}
     * @memberof SmartBlockContent
     */
    'position'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SmartBlockContent
     */
    'trackoffset': number;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockContent
     */
    'cliplength'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockContent
     */
    'cuein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockContent
     */
    'cueout'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockContent
     */
    'fadein'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockContent
     */
    'fadeout'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockContent
     */
    'block'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockContent
     */
    'file'?: string | null;
}
/**
 * 
 * @export
 * @interface SmartBlockCriteria
 */
export interface SmartBlockCriteria {
    /**
     * 
     * @type {string}
     * @memberof SmartBlockCriteria
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockCriteria
     */
    'criteria': string;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockCriteria
     */
    'modifier': string;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockCriteria
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockCriteria
     */
    'extra'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SmartBlockCriteria
     */
    'criteriagroup'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SmartBlockCriteria
     */
    'block': string;
}
/**
 * 
 * @export
 * @interface StationPodcast
 */
export interface StationPodcast {
    /**
     * 
     * @type {string}
     * @memberof StationPodcast
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof StationPodcast
     */
    'podcast': string;
}
/**
 * 
 * @export
 * @interface StreamSetting
 */
export interface StreamSetting {
    /**
     * 
     * @type {string}
     * @memberof StreamSetting
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof StreamSetting
     */
    'value'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StreamSetting
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ThirdPartyTrackReference
 */
export interface ThirdPartyTrackReference {
    /**
     * 
     * @type {string}
     * @memberof ThirdPartyTrackReference
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof ThirdPartyTrackReference
     */
    'service': string;
    /**
     * 
     * @type {string}
     * @memberof ThirdPartyTrackReference
     */
    'foreign_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThirdPartyTrackReference
     */
    'upload_time'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThirdPartyTrackReference
     */
    'status'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ThirdPartyTrackReference
     */
    'file'?: string | null;
}
/**
 * 
 * @export
 * @interface Timestamp
 */
export interface Timestamp {
    /**
     * 
     * @type {string}
     * @memberof Timestamp
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof Timestamp
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface TrackType
 */
export interface TrackType {
    /**
     * 
     * @type {string}
     * @memberof TrackType
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof TrackType
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof TrackType
     */
    'type_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TrackType
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TrackType
     */
    'visibility'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TypeEnum = {
    G: 'G',
    H: 'H',
    P: 'P',
    A: 'A'
} as const;

export type TypeEnum = typeof TypeEnum[keyof typeof TypeEnum];


/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {TypeEnum}
     * @memberof User
     */
    'type': TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastfail'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'skype_contact'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'jabber_contact'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'cell_phone'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'login_attempts'?: number | null;
}
/**
 * 
 * @export
 * @interface UserToken
 */
export interface UserToken {
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'action': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'created': string;
    /**
     * 
     * @type {string}
     * @memberof UserToken
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface Webstream
 */
export interface Webstream {
    /**
     * 
     * @type {string}
     * @memberof Webstream
     */
    'item_url': string;
    /**
     * 
     * @type {number}
     * @memberof Webstream
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Webstream
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Webstream
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Webstream
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof Webstream
     */
    'length': string;
    /**
     * 
     * @type {number}
     * @memberof Webstream
     */
    'creator_id': number;
    /**
     * 
     * @type {string}
     * @memberof Webstream
     */
    'mtime': string;
    /**
     * 
     * @type {string}
     * @memberof Webstream
     */
    'utime': string;
    /**
     * 
     * @type {string}
     * @memberof Webstream
     */
    'lptime'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Webstream
     */
    'mime'?: string | null;
}
/**
 * 
 * @export
 * @interface WebstreamMetadata
 */
export interface WebstreamMetadata {
    /**
     * 
     * @type {string}
     * @memberof WebstreamMetadata
     */
    'item_url': string;
    /**
     * 
     * @type {string}
     * @memberof WebstreamMetadata
     */
    'start_time': string;
    /**
     * 
     * @type {string}
     * @memberof WebstreamMetadata
     */
    'liquidsoap_data': string;
    /**
     * 
     * @type {string}
     * @memberof WebstreamMetadata
     */
    'instance': string;
}

/**
 * CeleryTasksApi - axios parameter creator
 * @export
 */
export const CeleryTasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CeleryTask} celeryTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksCreate: async (celeryTask: CeleryTask, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'celeryTask' is not null or undefined
            assertParamExists('celeryTasksCreate', 'celeryTask', celeryTask)
            const localVarPath = `/api/v2/celery-tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(celeryTask, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('celeryTasksDestroy', 'id', id)
            const localVarPath = `/api/v2/celery-tasks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/celery-tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {PatchedCeleryTask} [patchedCeleryTask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksPartialUpdate: async (id: number, patchedCeleryTask?: PatchedCeleryTask, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('celeryTasksPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/celery-tasks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCeleryTask, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('celeryTasksRetrieve', 'id', id)
            const localVarPath = `/api/v2/celery-tasks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {CeleryTask} celeryTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksUpdate: async (id: number, celeryTask: CeleryTask, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('celeryTasksUpdate', 'id', id)
            // verify required parameter 'celeryTask' is not null or undefined
            assertParamExists('celeryTasksUpdate', 'celeryTask', celeryTask)
            const localVarPath = `/api/v2/celery-tasks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(celeryTask, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CeleryTasksApi - functional programming interface
 * @export
 */
export const CeleryTasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CeleryTasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CeleryTask} celeryTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async celeryTasksCreate(celeryTask: CeleryTask, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CeleryTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.celeryTasksCreate(celeryTask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async celeryTasksDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.celeryTasksDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async celeryTasksList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CeleryTask>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.celeryTasksList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {PatchedCeleryTask} [patchedCeleryTask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async celeryTasksPartialUpdate(id: number, patchedCeleryTask?: PatchedCeleryTask, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CeleryTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.celeryTasksPartialUpdate(id, patchedCeleryTask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async celeryTasksRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CeleryTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.celeryTasksRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {CeleryTask} celeryTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async celeryTasksUpdate(id: number, celeryTask: CeleryTask, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CeleryTask>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.celeryTasksUpdate(id, celeryTask, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CeleryTasksApi - factory interface
 * @export
 */
export const CeleryTasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CeleryTasksApiFp(configuration)
    return {
        /**
         * 
         * @param {CeleryTask} celeryTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksCreate(celeryTask: CeleryTask, options?: any): AxiosPromise<CeleryTask> {
            return localVarFp.celeryTasksCreate(celeryTask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.celeryTasksDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksList(options?: any): AxiosPromise<Array<CeleryTask>> {
            return localVarFp.celeryTasksList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {PatchedCeleryTask} [patchedCeleryTask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksPartialUpdate(id: number, patchedCeleryTask?: PatchedCeleryTask, options?: any): AxiosPromise<CeleryTask> {
            return localVarFp.celeryTasksPartialUpdate(id, patchedCeleryTask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksRetrieve(id: number, options?: any): AxiosPromise<CeleryTask> {
            return localVarFp.celeryTasksRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this celery task.
         * @param {CeleryTask} celeryTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        celeryTasksUpdate(id: number, celeryTask: CeleryTask, options?: any): AxiosPromise<CeleryTask> {
            return localVarFp.celeryTasksUpdate(id, celeryTask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CeleryTasksApi - object-oriented interface
 * @export
 * @class CeleryTasksApi
 * @extends {BaseAPI}
 */
export class CeleryTasksApi extends BaseAPI {
    /**
     * 
     * @param {CeleryTask} celeryTask 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CeleryTasksApi
     */
    public celeryTasksCreate(celeryTask: CeleryTask, options?: AxiosRequestConfig) {
        return CeleryTasksApiFp(this.configuration).celeryTasksCreate(celeryTask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this celery task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CeleryTasksApi
     */
    public celeryTasksDestroy(id: number, options?: AxiosRequestConfig) {
        return CeleryTasksApiFp(this.configuration).celeryTasksDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CeleryTasksApi
     */
    public celeryTasksList(options?: AxiosRequestConfig) {
        return CeleryTasksApiFp(this.configuration).celeryTasksList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this celery task.
     * @param {PatchedCeleryTask} [patchedCeleryTask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CeleryTasksApi
     */
    public celeryTasksPartialUpdate(id: number, patchedCeleryTask?: PatchedCeleryTask, options?: AxiosRequestConfig) {
        return CeleryTasksApiFp(this.configuration).celeryTasksPartialUpdate(id, patchedCeleryTask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this celery task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CeleryTasksApi
     */
    public celeryTasksRetrieve(id: number, options?: AxiosRequestConfig) {
        return CeleryTasksApiFp(this.configuration).celeryTasksRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this celery task.
     * @param {CeleryTask} celeryTask 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CeleryTasksApi
     */
    public celeryTasksUpdate(id: number, celeryTask: CeleryTask, options?: AxiosRequestConfig) {
        return CeleryTasksApiFp(this.configuration).celeryTasksUpdate(id, celeryTask, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CloudFilesApi - axios parameter creator
 * @export
 */
export const CloudFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CloudFile} cloudFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesCreate: async (cloudFile: CloudFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudFile' is not null or undefined
            assertParamExists('cloudFilesCreate', 'cloudFile', cloudFile)
            const localVarPath = `/api/v2/cloud-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cloudFilesDestroy', 'id', id)
            const localVarPath = `/api/v2/cloud-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/cloud-files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {PatchedCloudFile} [patchedCloudFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesPartialUpdate: async (id: number, patchedCloudFile?: PatchedCloudFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cloudFilesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/cloud-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCloudFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cloudFilesRetrieve', 'id', id)
            const localVarPath = `/api/v2/cloud-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {CloudFile} cloudFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesUpdate: async (id: number, cloudFile: CloudFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cloudFilesUpdate', 'id', id)
            // verify required parameter 'cloudFile' is not null or undefined
            assertParamExists('cloudFilesUpdate', 'cloudFile', cloudFile)
            const localVarPath = `/api/v2/cloud-files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudFilesApi - functional programming interface
 * @export
 */
export const CloudFilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudFilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CloudFile} cloudFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudFilesCreate(cloudFile: CloudFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudFilesCreate(cloudFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudFilesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudFilesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudFilesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CloudFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudFilesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {PatchedCloudFile} [patchedCloudFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudFilesPartialUpdate(id: number, patchedCloudFile?: PatchedCloudFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudFilesPartialUpdate(id, patchedCloudFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudFilesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudFilesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {CloudFile} cloudFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloudFilesUpdate(id: number, cloudFile: CloudFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloudFilesUpdate(id, cloudFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CloudFilesApi - factory interface
 * @export
 */
export const CloudFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudFilesApiFp(configuration)
    return {
        /**
         * 
         * @param {CloudFile} cloudFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesCreate(cloudFile: CloudFile, options?: any): AxiosPromise<CloudFile> {
            return localVarFp.cloudFilesCreate(cloudFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.cloudFilesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesList(options?: any): AxiosPromise<Array<CloudFile>> {
            return localVarFp.cloudFilesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {PatchedCloudFile} [patchedCloudFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesPartialUpdate(id: number, patchedCloudFile?: PatchedCloudFile, options?: any): AxiosPromise<CloudFile> {
            return localVarFp.cloudFilesPartialUpdate(id, patchedCloudFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesRetrieve(id: number, options?: any): AxiosPromise<CloudFile> {
            return localVarFp.cloudFilesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cloud file.
         * @param {CloudFile} cloudFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloudFilesUpdate(id: number, cloudFile: CloudFile, options?: any): AxiosPromise<CloudFile> {
            return localVarFp.cloudFilesUpdate(id, cloudFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CloudFilesApi - object-oriented interface
 * @export
 * @class CloudFilesApi
 * @extends {BaseAPI}
 */
export class CloudFilesApi extends BaseAPI {
    /**
     * 
     * @param {CloudFile} cloudFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudFilesApi
     */
    public cloudFilesCreate(cloudFile: CloudFile, options?: AxiosRequestConfig) {
        return CloudFilesApiFp(this.configuration).cloudFilesCreate(cloudFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cloud file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudFilesApi
     */
    public cloudFilesDestroy(id: number, options?: AxiosRequestConfig) {
        return CloudFilesApiFp(this.configuration).cloudFilesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudFilesApi
     */
    public cloudFilesList(options?: AxiosRequestConfig) {
        return CloudFilesApiFp(this.configuration).cloudFilesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cloud file.
     * @param {PatchedCloudFile} [patchedCloudFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudFilesApi
     */
    public cloudFilesPartialUpdate(id: number, patchedCloudFile?: PatchedCloudFile, options?: AxiosRequestConfig) {
        return CloudFilesApiFp(this.configuration).cloudFilesPartialUpdate(id, patchedCloudFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cloud file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudFilesApi
     */
    public cloudFilesRetrieve(id: number, options?: AxiosRequestConfig) {
        return CloudFilesApiFp(this.configuration).cloudFilesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cloud file.
     * @param {CloudFile} cloudFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CloudFilesApi
     */
    public cloudFilesUpdate(id: number, cloudFile: CloudFile, options?: AxiosRequestConfig) {
        return CloudFilesApiFp(this.configuration).cloudFilesUpdate(id, cloudFile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Country} country 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCreate: async (country: Country, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countriesCreate', 'country', country)
            const localVarPath = `/api/v2/countries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(country, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesDestroy: async (isocode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isocode' is not null or undefined
            assertParamExists('countriesDestroy', 'isocode', isocode)
            const localVarPath = `/api/v2/countries/{isocode}/`
                .replace(`{${"isocode"}}`, encodeURIComponent(String(isocode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/countries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {PatchedCountry} [patchedCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesPartialUpdate: async (isocode: string, patchedCountry?: PatchedCountry, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isocode' is not null or undefined
            assertParamExists('countriesPartialUpdate', 'isocode', isocode)
            const localVarPath = `/api/v2/countries/{isocode}/`
                .replace(`{${"isocode"}}`, encodeURIComponent(String(isocode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCountry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesRetrieve: async (isocode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isocode' is not null or undefined
            assertParamExists('countriesRetrieve', 'isocode', isocode)
            const localVarPath = `/api/v2/countries/{isocode}/`
                .replace(`{${"isocode"}}`, encodeURIComponent(String(isocode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {Country} country 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesUpdate: async (isocode: string, country: Country, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'isocode' is not null or undefined
            assertParamExists('countriesUpdate', 'isocode', isocode)
            // verify required parameter 'country' is not null or undefined
            assertParamExists('countriesUpdate', 'country', country)
            const localVarPath = `/api/v2/countries/{isocode}/`
                .replace(`{${"isocode"}}`, encodeURIComponent(String(isocode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(country, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Country} country 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesCreate(country: Country, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesCreate(country, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesDestroy(isocode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesDestroy(isocode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Country>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {PatchedCountry} [patchedCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesPartialUpdate(isocode: string, patchedCountry?: PatchedCountry, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesPartialUpdate(isocode, patchedCountry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesRetrieve(isocode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesRetrieve(isocode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {Country} country 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countriesUpdate(isocode: string, country: Country, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countriesUpdate(isocode, country, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountriesApiFp(configuration)
    return {
        /**
         * 
         * @param {Country} country 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesCreate(country: Country, options?: any): AxiosPromise<Country> {
            return localVarFp.countriesCreate(country, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesDestroy(isocode: string, options?: any): AxiosPromise<void> {
            return localVarFp.countriesDestroy(isocode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesList(options?: any): AxiosPromise<Array<Country>> {
            return localVarFp.countriesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {PatchedCountry} [patchedCountry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesPartialUpdate(isocode: string, patchedCountry?: PatchedCountry, options?: any): AxiosPromise<Country> {
            return localVarFp.countriesPartialUpdate(isocode, patchedCountry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesRetrieve(isocode: string, options?: any): AxiosPromise<Country> {
            return localVarFp.countriesRetrieve(isocode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} isocode A unique value identifying this country.
         * @param {Country} country 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesUpdate(isocode: string, country: Country, options?: any): AxiosPromise<Country> {
            return localVarFp.countriesUpdate(isocode, country, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * 
     * @param {Country} country 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public countriesCreate(country: Country, options?: AxiosRequestConfig) {
        return CountriesApiFp(this.configuration).countriesCreate(country, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} isocode A unique value identifying this country.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public countriesDestroy(isocode: string, options?: AxiosRequestConfig) {
        return CountriesApiFp(this.configuration).countriesDestroy(isocode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public countriesList(options?: AxiosRequestConfig) {
        return CountriesApiFp(this.configuration).countriesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} isocode A unique value identifying this country.
     * @param {PatchedCountry} [patchedCountry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public countriesPartialUpdate(isocode: string, patchedCountry?: PatchedCountry, options?: AxiosRequestConfig) {
        return CountriesApiFp(this.configuration).countriesPartialUpdate(isocode, patchedCountry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} isocode A unique value identifying this country.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public countriesRetrieve(isocode: string, options?: AxiosRequestConfig) {
        return CountriesApiFp(this.configuration).countriesRetrieve(isocode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} isocode A unique value identifying this country.
     * @param {Country} country 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public countriesUpdate(isocode: string, country: Country, options?: AxiosRequestConfig) {
        return CountriesApiFp(this.configuration).countriesUpdate(isocode, country, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesCreate: async (modelFile: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelFile' is not null or undefined
            assertParamExists('filesCreate', 'modelFile', modelFile)
            const localVarPath = `/api/v2/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filesDestroy', 'id', id)
            const localVarPath = `/api/v2/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesDownloadRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filesDownloadRetrieve', 'id', id)
            const localVarPath = `/api/v2/files/{id}/download/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/files/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {PatchedFile} [patchedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPartialUpdate: async (id: number, patchedFile?: PatchedFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filesRetrieve', 'id', id)
            const localVarPath = `/api/v2/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesUpdate: async (id: number, modelFile: ModelFile, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('filesUpdate', 'id', id)
            // verify required parameter 'modelFile' is not null or undefined
            assertParamExists('filesUpdate', 'modelFile', modelFile)
            const localVarPath = `/api/v2/files/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelFile, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesCreate(modelFile: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesCreate(modelFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesDownloadRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesDownloadRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {PatchedFile} [patchedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesPartialUpdate(id: number, patchedFile?: PatchedFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesPartialUpdate(id, patchedFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesUpdate(id: number, modelFile: ModelFile, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesUpdate(id, modelFile, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesCreate(modelFile: ModelFile, options?: any): AxiosPromise<any> {
            return localVarFp.filesCreate(modelFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.filesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesDownloadRetrieve(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.filesDownloadRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesList(options?: any): AxiosPromise<Array<any>> {
            return localVarFp.filesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {PatchedFile} [patchedFile] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesPartialUpdate(id: number, patchedFile?: PatchedFile, options?: any): AxiosPromise<any> {
            return localVarFp.filesPartialUpdate(id, patchedFile, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesRetrieve(id: number, options?: any): AxiosPromise<any> {
            return localVarFp.filesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this file.
         * @param {ModelFile} modelFile 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesUpdate(id: number, modelFile: ModelFile, options?: any): AxiosPromise<any> {
            return localVarFp.filesUpdate(id, modelFile, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @param {ModelFile} modelFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesCreate(modelFile: ModelFile, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesCreate(modelFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesDestroy(id: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesDownloadRetrieve(id: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesDownloadRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesList(options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this file.
     * @param {PatchedFile} [patchedFile] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesPartialUpdate(id: number, patchedFile?: PatchedFile, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesPartialUpdate(id, patchedFile, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesRetrieve(id: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this file.
     * @param {ModelFile} modelFile 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesUpdate(id: number, modelFile: ModelFile, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesUpdate(id, modelFile, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImportedPodcastsApi - axios parameter creator
 * @export
 */
export const ImportedPodcastsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ImportedPodcast} importedPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsCreate: async (importedPodcast: ImportedPodcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'importedPodcast' is not null or undefined
            assertParamExists('importedPodcastsCreate', 'importedPodcast', importedPodcast)
            const localVarPath = `/api/v2/imported-podcasts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importedPodcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importedPodcastsDestroy', 'id', id)
            const localVarPath = `/api/v2/imported-podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/imported-podcasts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {PatchedImportedPodcast} [patchedImportedPodcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsPartialUpdate: async (id: number, patchedImportedPodcast?: PatchedImportedPodcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importedPodcastsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/imported-podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedImportedPodcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importedPodcastsRetrieve', 'id', id)
            const localVarPath = `/api/v2/imported-podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {ImportedPodcast} importedPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsUpdate: async (id: number, importedPodcast: ImportedPodcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('importedPodcastsUpdate', 'id', id)
            // verify required parameter 'importedPodcast' is not null or undefined
            assertParamExists('importedPodcastsUpdate', 'importedPodcast', importedPodcast)
            const localVarPath = `/api/v2/imported-podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importedPodcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportedPodcastsApi - functional programming interface
 * @export
 */
export const ImportedPodcastsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImportedPodcastsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ImportedPodcast} importedPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importedPodcastsCreate(importedPodcast: ImportedPodcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportedPodcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importedPodcastsCreate(importedPodcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importedPodcastsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importedPodcastsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importedPodcastsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImportedPodcast>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importedPodcastsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {PatchedImportedPodcast} [patchedImportedPodcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importedPodcastsPartialUpdate(id: number, patchedImportedPodcast?: PatchedImportedPodcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportedPodcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importedPodcastsPartialUpdate(id, patchedImportedPodcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importedPodcastsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportedPodcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importedPodcastsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {ImportedPodcast} importedPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importedPodcastsUpdate(id: number, importedPodcast: ImportedPodcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportedPodcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importedPodcastsUpdate(id, importedPodcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImportedPodcastsApi - factory interface
 * @export
 */
export const ImportedPodcastsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImportedPodcastsApiFp(configuration)
    return {
        /**
         * 
         * @param {ImportedPodcast} importedPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsCreate(importedPodcast: ImportedPodcast, options?: any): AxiosPromise<ImportedPodcast> {
            return localVarFp.importedPodcastsCreate(importedPodcast, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.importedPodcastsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsList(options?: any): AxiosPromise<Array<ImportedPodcast>> {
            return localVarFp.importedPodcastsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {PatchedImportedPodcast} [patchedImportedPodcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsPartialUpdate(id: number, patchedImportedPodcast?: PatchedImportedPodcast, options?: any): AxiosPromise<ImportedPodcast> {
            return localVarFp.importedPodcastsPartialUpdate(id, patchedImportedPodcast, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsRetrieve(id: number, options?: any): AxiosPromise<ImportedPodcast> {
            return localVarFp.importedPodcastsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this imported podcast.
         * @param {ImportedPodcast} importedPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importedPodcastsUpdate(id: number, importedPodcast: ImportedPodcast, options?: any): AxiosPromise<ImportedPodcast> {
            return localVarFp.importedPodcastsUpdate(id, importedPodcast, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImportedPodcastsApi - object-oriented interface
 * @export
 * @class ImportedPodcastsApi
 * @extends {BaseAPI}
 */
export class ImportedPodcastsApi extends BaseAPI {
    /**
     * 
     * @param {ImportedPodcast} importedPodcast 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportedPodcastsApi
     */
    public importedPodcastsCreate(importedPodcast: ImportedPodcast, options?: AxiosRequestConfig) {
        return ImportedPodcastsApiFp(this.configuration).importedPodcastsCreate(importedPodcast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this imported podcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportedPodcastsApi
     */
    public importedPodcastsDestroy(id: number, options?: AxiosRequestConfig) {
        return ImportedPodcastsApiFp(this.configuration).importedPodcastsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportedPodcastsApi
     */
    public importedPodcastsList(options?: AxiosRequestConfig) {
        return ImportedPodcastsApiFp(this.configuration).importedPodcastsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this imported podcast.
     * @param {PatchedImportedPodcast} [patchedImportedPodcast] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportedPodcastsApi
     */
    public importedPodcastsPartialUpdate(id: number, patchedImportedPodcast?: PatchedImportedPodcast, options?: AxiosRequestConfig) {
        return ImportedPodcastsApiFp(this.configuration).importedPodcastsPartialUpdate(id, patchedImportedPodcast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this imported podcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportedPodcastsApi
     */
    public importedPodcastsRetrieve(id: number, options?: AxiosRequestConfig) {
        return ImportedPodcastsApiFp(this.configuration).importedPodcastsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this imported podcast.
     * @param {ImportedPodcast} importedPodcast 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportedPodcastsApi
     */
    public importedPodcastsUpdate(id: number, importedPodcast: ImportedPodcast, options?: AxiosRequestConfig) {
        return ImportedPodcastsApiFp(this.configuration).importedPodcastsUpdate(id, importedPodcast, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ListenerCountsApi - axios parameter creator
 * @export
 */
export const ListenerCountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ListenerCount} listenerCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsCreate: async (listenerCount: ListenerCount, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listenerCount' is not null or undefined
            assertParamExists('listenerCountsCreate', 'listenerCount', listenerCount)
            const localVarPath = `/api/v2/listener-counts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listenerCount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listenerCountsDestroy', 'id', id)
            const localVarPath = `/api/v2/listener-counts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/listener-counts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {PatchedListenerCount} [patchedListenerCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsPartialUpdate: async (id: number, patchedListenerCount?: PatchedListenerCount, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listenerCountsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/listener-counts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedListenerCount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listenerCountsRetrieve', 'id', id)
            const localVarPath = `/api/v2/listener-counts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {ListenerCount} listenerCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsUpdate: async (id: number, listenerCount: ListenerCount, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listenerCountsUpdate', 'id', id)
            // verify required parameter 'listenerCount' is not null or undefined
            assertParamExists('listenerCountsUpdate', 'listenerCount', listenerCount)
            const localVarPath = `/api/v2/listener-counts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listenerCount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListenerCountsApi - functional programming interface
 * @export
 */
export const ListenerCountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListenerCountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ListenerCount} listenerCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listenerCountsCreate(listenerCount: ListenerCount, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListenerCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listenerCountsCreate(listenerCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listenerCountsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listenerCountsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listenerCountsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListenerCount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listenerCountsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {PatchedListenerCount} [patchedListenerCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listenerCountsPartialUpdate(id: number, patchedListenerCount?: PatchedListenerCount, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListenerCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listenerCountsPartialUpdate(id, patchedListenerCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listenerCountsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListenerCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listenerCountsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {ListenerCount} listenerCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listenerCountsUpdate(id: number, listenerCount: ListenerCount, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListenerCount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listenerCountsUpdate(id, listenerCount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListenerCountsApi - factory interface
 * @export
 */
export const ListenerCountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListenerCountsApiFp(configuration)
    return {
        /**
         * 
         * @param {ListenerCount} listenerCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsCreate(listenerCount: ListenerCount, options?: any): AxiosPromise<ListenerCount> {
            return localVarFp.listenerCountsCreate(listenerCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.listenerCountsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsList(options?: any): AxiosPromise<Array<ListenerCount>> {
            return localVarFp.listenerCountsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {PatchedListenerCount} [patchedListenerCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsPartialUpdate(id: number, patchedListenerCount?: PatchedListenerCount, options?: any): AxiosPromise<ListenerCount> {
            return localVarFp.listenerCountsPartialUpdate(id, patchedListenerCount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsRetrieve(id: number, options?: any): AxiosPromise<ListenerCount> {
            return localVarFp.listenerCountsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this listener count.
         * @param {ListenerCount} listenerCount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenerCountsUpdate(id: number, listenerCount: ListenerCount, options?: any): AxiosPromise<ListenerCount> {
            return localVarFp.listenerCountsUpdate(id, listenerCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListenerCountsApi - object-oriented interface
 * @export
 * @class ListenerCountsApi
 * @extends {BaseAPI}
 */
export class ListenerCountsApi extends BaseAPI {
    /**
     * 
     * @param {ListenerCount} listenerCount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerCountsApi
     */
    public listenerCountsCreate(listenerCount: ListenerCount, options?: AxiosRequestConfig) {
        return ListenerCountsApiFp(this.configuration).listenerCountsCreate(listenerCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this listener count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerCountsApi
     */
    public listenerCountsDestroy(id: number, options?: AxiosRequestConfig) {
        return ListenerCountsApiFp(this.configuration).listenerCountsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerCountsApi
     */
    public listenerCountsList(options?: AxiosRequestConfig) {
        return ListenerCountsApiFp(this.configuration).listenerCountsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this listener count.
     * @param {PatchedListenerCount} [patchedListenerCount] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerCountsApi
     */
    public listenerCountsPartialUpdate(id: number, patchedListenerCount?: PatchedListenerCount, options?: AxiosRequestConfig) {
        return ListenerCountsApiFp(this.configuration).listenerCountsPartialUpdate(id, patchedListenerCount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this listener count.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerCountsApi
     */
    public listenerCountsRetrieve(id: number, options?: AxiosRequestConfig) {
        return ListenerCountsApiFp(this.configuration).listenerCountsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this listener count.
     * @param {ListenerCount} listenerCount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListenerCountsApi
     */
    public listenerCountsUpdate(id: number, listenerCount: ListenerCount, options?: AxiosRequestConfig) {
        return ListenerCountsApiFp(this.configuration).listenerCountsUpdate(id, listenerCount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LiveLogsApi - axios parameter creator
 * @export
 */
export const LiveLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LiveLog} liveLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsCreate: async (liveLog: LiveLog, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'liveLog' is not null or undefined
            assertParamExists('liveLogsCreate', 'liveLog', liveLog)
            const localVarPath = `/api/v2/live-logs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(liveLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('liveLogsDestroy', 'id', id)
            const localVarPath = `/api/v2/live-logs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/live-logs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {PatchedLiveLog} [patchedLiveLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsPartialUpdate: async (id: number, patchedLiveLog?: PatchedLiveLog, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('liveLogsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/live-logs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedLiveLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('liveLogsRetrieve', 'id', id)
            const localVarPath = `/api/v2/live-logs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {LiveLog} liveLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsUpdate: async (id: number, liveLog: LiveLog, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('liveLogsUpdate', 'id', id)
            // verify required parameter 'liveLog' is not null or undefined
            assertParamExists('liveLogsUpdate', 'liveLog', liveLog)
            const localVarPath = `/api/v2/live-logs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(liveLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LiveLogsApi - functional programming interface
 * @export
 */
export const LiveLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LiveLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LiveLog} liveLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liveLogsCreate(liveLog: LiveLog, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liveLogsCreate(liveLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liveLogsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liveLogsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liveLogsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LiveLog>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liveLogsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {PatchedLiveLog} [patchedLiveLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liveLogsPartialUpdate(id: number, patchedLiveLog?: PatchedLiveLog, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liveLogsPartialUpdate(id, patchedLiveLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liveLogsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liveLogsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {LiveLog} liveLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async liveLogsUpdate(id: number, liveLog: LiveLog, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LiveLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.liveLogsUpdate(id, liveLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LiveLogsApi - factory interface
 * @export
 */
export const LiveLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LiveLogsApiFp(configuration)
    return {
        /**
         * 
         * @param {LiveLog} liveLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsCreate(liveLog: LiveLog, options?: any): AxiosPromise<LiveLog> {
            return localVarFp.liveLogsCreate(liveLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.liveLogsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsList(options?: any): AxiosPromise<Array<LiveLog>> {
            return localVarFp.liveLogsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {PatchedLiveLog} [patchedLiveLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsPartialUpdate(id: number, patchedLiveLog?: PatchedLiveLog, options?: any): AxiosPromise<LiveLog> {
            return localVarFp.liveLogsPartialUpdate(id, patchedLiveLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsRetrieve(id: number, options?: any): AxiosPromise<LiveLog> {
            return localVarFp.liveLogsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this live log.
         * @param {LiveLog} liveLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        liveLogsUpdate(id: number, liveLog: LiveLog, options?: any): AxiosPromise<LiveLog> {
            return localVarFp.liveLogsUpdate(id, liveLog, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LiveLogsApi - object-oriented interface
 * @export
 * @class LiveLogsApi
 * @extends {BaseAPI}
 */
export class LiveLogsApi extends BaseAPI {
    /**
     * 
     * @param {LiveLog} liveLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveLogsApi
     */
    public liveLogsCreate(liveLog: LiveLog, options?: AxiosRequestConfig) {
        return LiveLogsApiFp(this.configuration).liveLogsCreate(liveLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this live log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveLogsApi
     */
    public liveLogsDestroy(id: number, options?: AxiosRequestConfig) {
        return LiveLogsApiFp(this.configuration).liveLogsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveLogsApi
     */
    public liveLogsList(options?: AxiosRequestConfig) {
        return LiveLogsApiFp(this.configuration).liveLogsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this live log.
     * @param {PatchedLiveLog} [patchedLiveLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveLogsApi
     */
    public liveLogsPartialUpdate(id: number, patchedLiveLog?: PatchedLiveLog, options?: AxiosRequestConfig) {
        return LiveLogsApiFp(this.configuration).liveLogsPartialUpdate(id, patchedLiveLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this live log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveLogsApi
     */
    public liveLogsRetrieve(id: number, options?: AxiosRequestConfig) {
        return LiveLogsApiFp(this.configuration).liveLogsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this live log.
     * @param {LiveLog} liveLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LiveLogsApi
     */
    public liveLogsUpdate(id: number, liveLog: LiveLog, options?: AxiosRequestConfig) {
        return LiveLogsApiFp(this.configuration).liveLogsUpdate(id, liveLog, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LoginAttemptsApi - axios parameter creator
 * @export
 */
export const LoginAttemptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginAttempt} [loginAttempt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsCreate: async (loginAttempt?: LoginAttempt, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/login-attempts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginAttempt, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsDestroy: async (ip: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('loginAttemptsDestroy', 'ip', ip)
            const localVarPath = `/api/v2/login-attempts/{ip}/`
                .replace(`{${"ip"}}`, encodeURIComponent(String(ip)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/login-attempts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {PatchedLoginAttempt} [patchedLoginAttempt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsPartialUpdate: async (ip: string, patchedLoginAttempt?: PatchedLoginAttempt, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('loginAttemptsPartialUpdate', 'ip', ip)
            const localVarPath = `/api/v2/login-attempts/{ip}/`
                .replace(`{${"ip"}}`, encodeURIComponent(String(ip)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedLoginAttempt, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsRetrieve: async (ip: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('loginAttemptsRetrieve', 'ip', ip)
            const localVarPath = `/api/v2/login-attempts/{ip}/`
                .replace(`{${"ip"}}`, encodeURIComponent(String(ip)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {LoginAttempt} [loginAttempt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsUpdate: async (ip: string, loginAttempt?: LoginAttempt, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('loginAttemptsUpdate', 'ip', ip)
            const localVarPath = `/api/v2/login-attempts/{ip}/`
                .replace(`{${"ip"}}`, encodeURIComponent(String(ip)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginAttempt, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginAttemptsApi - functional programming interface
 * @export
 */
export const LoginAttemptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LoginAttemptsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginAttempt} [loginAttempt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAttemptsCreate(loginAttempt?: LoginAttempt, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginAttempt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAttemptsCreate(loginAttempt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAttemptsDestroy(ip: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAttemptsDestroy(ip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAttemptsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LoginAttempt>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAttemptsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {PatchedLoginAttempt} [patchedLoginAttempt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAttemptsPartialUpdate(ip: string, patchedLoginAttempt?: PatchedLoginAttempt, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginAttempt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAttemptsPartialUpdate(ip, patchedLoginAttempt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAttemptsRetrieve(ip: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginAttempt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAttemptsRetrieve(ip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {LoginAttempt} [loginAttempt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAttemptsUpdate(ip: string, loginAttempt?: LoginAttempt, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginAttempt>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAttemptsUpdate(ip, loginAttempt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LoginAttemptsApi - factory interface
 * @export
 */
export const LoginAttemptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LoginAttemptsApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginAttempt} [loginAttempt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsCreate(loginAttempt?: LoginAttempt, options?: any): AxiosPromise<LoginAttempt> {
            return localVarFp.loginAttemptsCreate(loginAttempt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsDestroy(ip: string, options?: any): AxiosPromise<void> {
            return localVarFp.loginAttemptsDestroy(ip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsList(options?: any): AxiosPromise<Array<LoginAttempt>> {
            return localVarFp.loginAttemptsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {PatchedLoginAttempt} [patchedLoginAttempt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsPartialUpdate(ip: string, patchedLoginAttempt?: PatchedLoginAttempt, options?: any): AxiosPromise<LoginAttempt> {
            return localVarFp.loginAttemptsPartialUpdate(ip, patchedLoginAttempt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsRetrieve(ip: string, options?: any): AxiosPromise<LoginAttempt> {
            return localVarFp.loginAttemptsRetrieve(ip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ip A unique value identifying this login attempt.
         * @param {LoginAttempt} [loginAttempt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAttemptsUpdate(ip: string, loginAttempt?: LoginAttempt, options?: any): AxiosPromise<LoginAttempt> {
            return localVarFp.loginAttemptsUpdate(ip, loginAttempt, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LoginAttemptsApi - object-oriented interface
 * @export
 * @class LoginAttemptsApi
 * @extends {BaseAPI}
 */
export class LoginAttemptsApi extends BaseAPI {
    /**
     * 
     * @param {LoginAttempt} [loginAttempt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAttemptsApi
     */
    public loginAttemptsCreate(loginAttempt?: LoginAttempt, options?: AxiosRequestConfig) {
        return LoginAttemptsApiFp(this.configuration).loginAttemptsCreate(loginAttempt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ip A unique value identifying this login attempt.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAttemptsApi
     */
    public loginAttemptsDestroy(ip: string, options?: AxiosRequestConfig) {
        return LoginAttemptsApiFp(this.configuration).loginAttemptsDestroy(ip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAttemptsApi
     */
    public loginAttemptsList(options?: AxiosRequestConfig) {
        return LoginAttemptsApiFp(this.configuration).loginAttemptsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ip A unique value identifying this login attempt.
     * @param {PatchedLoginAttempt} [patchedLoginAttempt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAttemptsApi
     */
    public loginAttemptsPartialUpdate(ip: string, patchedLoginAttempt?: PatchedLoginAttempt, options?: AxiosRequestConfig) {
        return LoginAttemptsApiFp(this.configuration).loginAttemptsPartialUpdate(ip, patchedLoginAttempt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ip A unique value identifying this login attempt.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAttemptsApi
     */
    public loginAttemptsRetrieve(ip: string, options?: AxiosRequestConfig) {
        return LoginAttemptsApiFp(this.configuration).loginAttemptsRetrieve(ip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ip A unique value identifying this login attempt.
     * @param {LoginAttempt} [loginAttempt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginAttemptsApi
     */
    public loginAttemptsUpdate(ip: string, loginAttempt?: LoginAttempt, options?: AxiosRequestConfig) {
        return LoginAttemptsApiFp(this.configuration).loginAttemptsUpdate(ip, loginAttempt, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MountNamesApi - axios parameter creator
 * @export
 */
export const MountNamesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MountName} mountName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesCreate: async (mountName: MountName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mountName' is not null or undefined
            assertParamExists('mountNamesCreate', 'mountName', mountName)
            const localVarPath = `/api/v2/mount-names/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mountName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mountNamesDestroy', 'id', id)
            const localVarPath = `/api/v2/mount-names/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/mount-names/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {PatchedMountName} [patchedMountName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesPartialUpdate: async (id: number, patchedMountName?: PatchedMountName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mountNamesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/mount-names/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMountName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mountNamesRetrieve', 'id', id)
            const localVarPath = `/api/v2/mount-names/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {MountName} mountName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesUpdate: async (id: number, mountName: MountName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mountNamesUpdate', 'id', id)
            // verify required parameter 'mountName' is not null or undefined
            assertParamExists('mountNamesUpdate', 'mountName', mountName)
            const localVarPath = `/api/v2/mount-names/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mountName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MountNamesApi - functional programming interface
 * @export
 */
export const MountNamesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MountNamesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MountName} mountName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mountNamesCreate(mountName: MountName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MountName>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mountNamesCreate(mountName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mountNamesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mountNamesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mountNamesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MountName>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mountNamesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {PatchedMountName} [patchedMountName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mountNamesPartialUpdate(id: number, patchedMountName?: PatchedMountName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MountName>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mountNamesPartialUpdate(id, patchedMountName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mountNamesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MountName>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mountNamesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {MountName} mountName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mountNamesUpdate(id: number, mountName: MountName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MountName>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mountNamesUpdate(id, mountName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MountNamesApi - factory interface
 * @export
 */
export const MountNamesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MountNamesApiFp(configuration)
    return {
        /**
         * 
         * @param {MountName} mountName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesCreate(mountName: MountName, options?: any): AxiosPromise<MountName> {
            return localVarFp.mountNamesCreate(mountName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.mountNamesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesList(options?: any): AxiosPromise<Array<MountName>> {
            return localVarFp.mountNamesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {PatchedMountName} [patchedMountName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesPartialUpdate(id: number, patchedMountName?: PatchedMountName, options?: any): AxiosPromise<MountName> {
            return localVarFp.mountNamesPartialUpdate(id, patchedMountName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesRetrieve(id: number, options?: any): AxiosPromise<MountName> {
            return localVarFp.mountNamesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this mount name.
         * @param {MountName} mountName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mountNamesUpdate(id: number, mountName: MountName, options?: any): AxiosPromise<MountName> {
            return localVarFp.mountNamesUpdate(id, mountName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MountNamesApi - object-oriented interface
 * @export
 * @class MountNamesApi
 * @extends {BaseAPI}
 */
export class MountNamesApi extends BaseAPI {
    /**
     * 
     * @param {MountName} mountName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountNamesApi
     */
    public mountNamesCreate(mountName: MountName, options?: AxiosRequestConfig) {
        return MountNamesApiFp(this.configuration).mountNamesCreate(mountName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this mount name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountNamesApi
     */
    public mountNamesDestroy(id: number, options?: AxiosRequestConfig) {
        return MountNamesApiFp(this.configuration).mountNamesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountNamesApi
     */
    public mountNamesList(options?: AxiosRequestConfig) {
        return MountNamesApiFp(this.configuration).mountNamesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this mount name.
     * @param {PatchedMountName} [patchedMountName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountNamesApi
     */
    public mountNamesPartialUpdate(id: number, patchedMountName?: PatchedMountName, options?: AxiosRequestConfig) {
        return MountNamesApiFp(this.configuration).mountNamesPartialUpdate(id, patchedMountName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this mount name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountNamesApi
     */
    public mountNamesRetrieve(id: number, options?: AxiosRequestConfig) {
        return MountNamesApiFp(this.configuration).mountNamesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this mount name.
     * @param {MountName} mountName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MountNamesApi
     */
    public mountNamesUpdate(id: number, mountName: MountName, options?: AxiosRequestConfig) {
        return MountNamesApiFp(this.configuration).mountNamesUpdate(id, mountName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MusicDirsApi - axios parameter creator
 * @export
 */
export const MusicDirsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MusicDir} [musicDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsCreate: async (musicDir?: MusicDir, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/music-dirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(musicDir, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('musicDirsDestroy', 'id', id)
            const localVarPath = `/api/v2/music-dirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/music-dirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {PatchedMusicDir} [patchedMusicDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsPartialUpdate: async (id: number, patchedMusicDir?: PatchedMusicDir, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('musicDirsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/music-dirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMusicDir, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('musicDirsRetrieve', 'id', id)
            const localVarPath = `/api/v2/music-dirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {MusicDir} [musicDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsUpdate: async (id: number, musicDir?: MusicDir, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('musicDirsUpdate', 'id', id)
            const localVarPath = `/api/v2/music-dirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(musicDir, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MusicDirsApi - functional programming interface
 * @export
 */
export const MusicDirsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MusicDirsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MusicDir} [musicDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async musicDirsCreate(musicDir?: MusicDir, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MusicDir>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.musicDirsCreate(musicDir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async musicDirsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.musicDirsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async musicDirsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MusicDir>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.musicDirsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {PatchedMusicDir} [patchedMusicDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async musicDirsPartialUpdate(id: number, patchedMusicDir?: PatchedMusicDir, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MusicDir>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.musicDirsPartialUpdate(id, patchedMusicDir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async musicDirsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MusicDir>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.musicDirsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {MusicDir} [musicDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async musicDirsUpdate(id: number, musicDir?: MusicDir, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MusicDir>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.musicDirsUpdate(id, musicDir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MusicDirsApi - factory interface
 * @export
 */
export const MusicDirsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MusicDirsApiFp(configuration)
    return {
        /**
         * 
         * @param {MusicDir} [musicDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsCreate(musicDir?: MusicDir, options?: any): AxiosPromise<MusicDir> {
            return localVarFp.musicDirsCreate(musicDir, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.musicDirsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsList(options?: any): AxiosPromise<Array<MusicDir>> {
            return localVarFp.musicDirsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {PatchedMusicDir} [patchedMusicDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsPartialUpdate(id: number, patchedMusicDir?: PatchedMusicDir, options?: any): AxiosPromise<MusicDir> {
            return localVarFp.musicDirsPartialUpdate(id, patchedMusicDir, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsRetrieve(id: number, options?: any): AxiosPromise<MusicDir> {
            return localVarFp.musicDirsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this music dir.
         * @param {MusicDir} [musicDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        musicDirsUpdate(id: number, musicDir?: MusicDir, options?: any): AxiosPromise<MusicDir> {
            return localVarFp.musicDirsUpdate(id, musicDir, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MusicDirsApi - object-oriented interface
 * @export
 * @class MusicDirsApi
 * @extends {BaseAPI}
 */
export class MusicDirsApi extends BaseAPI {
    /**
     * 
     * @param {MusicDir} [musicDir] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicDirsApi
     */
    public musicDirsCreate(musicDir?: MusicDir, options?: AxiosRequestConfig) {
        return MusicDirsApiFp(this.configuration).musicDirsCreate(musicDir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this music dir.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicDirsApi
     */
    public musicDirsDestroy(id: number, options?: AxiosRequestConfig) {
        return MusicDirsApiFp(this.configuration).musicDirsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicDirsApi
     */
    public musicDirsList(options?: AxiosRequestConfig) {
        return MusicDirsApiFp(this.configuration).musicDirsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this music dir.
     * @param {PatchedMusicDir} [patchedMusicDir] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicDirsApi
     */
    public musicDirsPartialUpdate(id: number, patchedMusicDir?: PatchedMusicDir, options?: AxiosRequestConfig) {
        return MusicDirsApiFp(this.configuration).musicDirsPartialUpdate(id, patchedMusicDir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this music dir.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicDirsApi
     */
    public musicDirsRetrieve(id: number, options?: AxiosRequestConfig) {
        return MusicDirsApiFp(this.configuration).musicDirsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this music dir.
     * @param {MusicDir} [musicDir] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicDirsApi
     */
    public musicDirsUpdate(id: number, musicDir?: MusicDir, options?: AxiosRequestConfig) {
        return MusicDirsApiFp(this.configuration).musicDirsUpdate(id, musicDir, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaylistContentsApi - axios parameter creator
 * @export
 */
export const PlaylistContentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PlaylistContent} playlistContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsCreate: async (playlistContent: PlaylistContent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlistContent' is not null or undefined
            assertParamExists('playlistContentsCreate', 'playlistContent', playlistContent)
            const localVarPath = `/api/v2/playlist-contents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playlistContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playlistContentsDestroy', 'id', id)
            const localVarPath = `/api/v2/playlist-contents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/playlist-contents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {PatchedPlaylistContent} [patchedPlaylistContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsPartialUpdate: async (id: number, patchedPlaylistContent?: PatchedPlaylistContent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playlistContentsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/playlist-contents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPlaylistContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playlistContentsRetrieve', 'id', id)
            const localVarPath = `/api/v2/playlist-contents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {PlaylistContent} playlistContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsUpdate: async (id: number, playlistContent: PlaylistContent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playlistContentsUpdate', 'id', id)
            // verify required parameter 'playlistContent' is not null or undefined
            assertParamExists('playlistContentsUpdate', 'playlistContent', playlistContent)
            const localVarPath = `/api/v2/playlist-contents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playlistContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistContentsApi - functional programming interface
 * @export
 */
export const PlaylistContentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistContentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PlaylistContent} playlistContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistContentsCreate(playlistContent: PlaylistContent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistContentsCreate(playlistContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistContentsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistContentsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistContentsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaylistContent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistContentsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {PatchedPlaylistContent} [patchedPlaylistContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistContentsPartialUpdate(id: number, patchedPlaylistContent?: PatchedPlaylistContent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistContentsPartialUpdate(id, patchedPlaylistContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistContentsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistContentsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {PlaylistContent} playlistContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistContentsUpdate(id: number, playlistContent: PlaylistContent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistContentsUpdate(id, playlistContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlaylistContentsApi - factory interface
 * @export
 */
export const PlaylistContentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistContentsApiFp(configuration)
    return {
        /**
         * 
         * @param {PlaylistContent} playlistContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsCreate(playlistContent: PlaylistContent, options?: any): AxiosPromise<PlaylistContent> {
            return localVarFp.playlistContentsCreate(playlistContent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.playlistContentsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsList(options?: any): AxiosPromise<Array<PlaylistContent>> {
            return localVarFp.playlistContentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {PatchedPlaylistContent} [patchedPlaylistContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsPartialUpdate(id: number, patchedPlaylistContent?: PatchedPlaylistContent, options?: any): AxiosPromise<PlaylistContent> {
            return localVarFp.playlistContentsPartialUpdate(id, patchedPlaylistContent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsRetrieve(id: number, options?: any): AxiosPromise<PlaylistContent> {
            return localVarFp.playlistContentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist content.
         * @param {PlaylistContent} playlistContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistContentsUpdate(id: number, playlistContent: PlaylistContent, options?: any): AxiosPromise<PlaylistContent> {
            return localVarFp.playlistContentsUpdate(id, playlistContent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistContentsApi - object-oriented interface
 * @export
 * @class PlaylistContentsApi
 * @extends {BaseAPI}
 */
export class PlaylistContentsApi extends BaseAPI {
    /**
     * 
     * @param {PlaylistContent} playlistContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistContentsApi
     */
    public playlistContentsCreate(playlistContent: PlaylistContent, options?: AxiosRequestConfig) {
        return PlaylistContentsApiFp(this.configuration).playlistContentsCreate(playlistContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playlist content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistContentsApi
     */
    public playlistContentsDestroy(id: number, options?: AxiosRequestConfig) {
        return PlaylistContentsApiFp(this.configuration).playlistContentsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistContentsApi
     */
    public playlistContentsList(options?: AxiosRequestConfig) {
        return PlaylistContentsApiFp(this.configuration).playlistContentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playlist content.
     * @param {PatchedPlaylistContent} [patchedPlaylistContent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistContentsApi
     */
    public playlistContentsPartialUpdate(id: number, patchedPlaylistContent?: PatchedPlaylistContent, options?: AxiosRequestConfig) {
        return PlaylistContentsApiFp(this.configuration).playlistContentsPartialUpdate(id, patchedPlaylistContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playlist content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistContentsApi
     */
    public playlistContentsRetrieve(id: number, options?: AxiosRequestConfig) {
        return PlaylistContentsApiFp(this.configuration).playlistContentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playlist content.
     * @param {PlaylistContent} playlistContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistContentsApi
     */
    public playlistContentsUpdate(id: number, playlistContent: PlaylistContent, options?: AxiosRequestConfig) {
        return PlaylistContentsApiFp(this.configuration).playlistContentsUpdate(id, playlistContent, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlaylistsApi - axios parameter creator
 * @export
 */
export const PlaylistsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Playlist} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsCreate: async (playlist: Playlist, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistsCreate', 'playlist', playlist)
            const localVarPath = `/api/v2/playlists/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playlist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playlistsDestroy', 'id', id)
            const localVarPath = `/api/v2/playlists/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/playlists/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {PatchedPlaylist} [patchedPlaylist] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsPartialUpdate: async (id: number, patchedPlaylist?: PatchedPlaylist, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playlistsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/playlists/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPlaylist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playlistsRetrieve', 'id', id)
            const localVarPath = `/api/v2/playlists/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {Playlist} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsUpdate: async (id: number, playlist: Playlist, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playlistsUpdate', 'id', id)
            // verify required parameter 'playlist' is not null or undefined
            assertParamExists('playlistsUpdate', 'playlist', playlist)
            const localVarPath = `/api/v2/playlists/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playlist, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaylistsApi - functional programming interface
 * @export
 */
export const PlaylistsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlaylistsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Playlist} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistsCreate(playlist: Playlist, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Playlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistsCreate(playlist, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Playlist>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {PatchedPlaylist} [patchedPlaylist] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistsPartialUpdate(id: number, patchedPlaylist?: PatchedPlaylist, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Playlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistsPartialUpdate(id, patchedPlaylist, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Playlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {Playlist} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playlistsUpdate(id: number, playlist: Playlist, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Playlist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playlistsUpdate(id, playlist, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlaylistsApi - factory interface
 * @export
 */
export const PlaylistsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlaylistsApiFp(configuration)
    return {
        /**
         * 
         * @param {Playlist} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsCreate(playlist: Playlist, options?: any): AxiosPromise<Playlist> {
            return localVarFp.playlistsCreate(playlist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.playlistsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsList(options?: any): AxiosPromise<Array<Playlist>> {
            return localVarFp.playlistsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {PatchedPlaylist} [patchedPlaylist] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsPartialUpdate(id: number, patchedPlaylist?: PatchedPlaylist, options?: any): AxiosPromise<Playlist> {
            return localVarFp.playlistsPartialUpdate(id, patchedPlaylist, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsRetrieve(id: number, options?: any): AxiosPromise<Playlist> {
            return localVarFp.playlistsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playlist.
         * @param {Playlist} playlist 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playlistsUpdate(id: number, playlist: Playlist, options?: any): AxiosPromise<Playlist> {
            return localVarFp.playlistsUpdate(id, playlist, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlaylistsApi - object-oriented interface
 * @export
 * @class PlaylistsApi
 * @extends {BaseAPI}
 */
export class PlaylistsApi extends BaseAPI {
    /**
     * 
     * @param {Playlist} playlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public playlistsCreate(playlist: Playlist, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).playlistsCreate(playlist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playlist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public playlistsDestroy(id: number, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).playlistsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public playlistsList(options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).playlistsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playlist.
     * @param {PatchedPlaylist} [patchedPlaylist] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public playlistsPartialUpdate(id: number, patchedPlaylist?: PatchedPlaylist, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).playlistsPartialUpdate(id, patchedPlaylist, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playlist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public playlistsRetrieve(id: number, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).playlistsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playlist.
     * @param {Playlist} playlist 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaylistsApi
     */
    public playlistsUpdate(id: number, playlist: Playlist, options?: AxiosRequestConfig) {
        return PlaylistsApiFp(this.configuration).playlistsUpdate(id, playlist, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayoutHistoryApi - axios parameter creator
 * @export
 */
export const PlayoutHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PlayoutHistory} playoutHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryCreate: async (playoutHistory: PlayoutHistory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playoutHistory' is not null or undefined
            assertParamExists('playoutHistoryCreate', 'playoutHistory', playoutHistory)
            const localVarPath = `/api/v2/playout-history/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playoutHistory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryDestroy', 'id', id)
            const localVarPath = `/api/v2/playout-history/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/playout-history/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {PatchedPlayoutHistory} [patchedPlayoutHistory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryPartialUpdate: async (id: number, patchedPlayoutHistory?: PatchedPlayoutHistory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/playout-history/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPlayoutHistory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryRetrieve', 'id', id)
            const localVarPath = `/api/v2/playout-history/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {PlayoutHistory} playoutHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryUpdate: async (id: number, playoutHistory: PlayoutHistory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryUpdate', 'id', id)
            // verify required parameter 'playoutHistory' is not null or undefined
            assertParamExists('playoutHistoryUpdate', 'playoutHistory', playoutHistory)
            const localVarPath = `/api/v2/playout-history/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playoutHistory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayoutHistoryApi - functional programming interface
 * @export
 */
export const PlayoutHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayoutHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PlayoutHistory} playoutHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryCreate(playoutHistory: PlayoutHistory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryCreate(playoutHistory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayoutHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {PatchedPlayoutHistory} [patchedPlayoutHistory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryPartialUpdate(id: number, patchedPlayoutHistory?: PatchedPlayoutHistory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryPartialUpdate(id, patchedPlayoutHistory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {PlayoutHistory} playoutHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryUpdate(id: number, playoutHistory: PlayoutHistory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryUpdate(id, playoutHistory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayoutHistoryApi - factory interface
 * @export
 */
export const PlayoutHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayoutHistoryApiFp(configuration)
    return {
        /**
         * 
         * @param {PlayoutHistory} playoutHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryCreate(playoutHistory: PlayoutHistory, options?: any): AxiosPromise<PlayoutHistory> {
            return localVarFp.playoutHistoryCreate(playoutHistory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.playoutHistoryDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryList(options?: any): AxiosPromise<Array<PlayoutHistory>> {
            return localVarFp.playoutHistoryList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {PatchedPlayoutHistory} [patchedPlayoutHistory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryPartialUpdate(id: number, patchedPlayoutHistory?: PatchedPlayoutHistory, options?: any): AxiosPromise<PlayoutHistory> {
            return localVarFp.playoutHistoryPartialUpdate(id, patchedPlayoutHistory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryRetrieve(id: number, options?: any): AxiosPromise<PlayoutHistory> {
            return localVarFp.playoutHistoryRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history.
         * @param {PlayoutHistory} playoutHistory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryUpdate(id: number, playoutHistory: PlayoutHistory, options?: any): AxiosPromise<PlayoutHistory> {
            return localVarFp.playoutHistoryUpdate(id, playoutHistory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayoutHistoryApi - object-oriented interface
 * @export
 * @class PlayoutHistoryApi
 * @extends {BaseAPI}
 */
export class PlayoutHistoryApi extends BaseAPI {
    /**
     * 
     * @param {PlayoutHistory} playoutHistory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryApi
     */
    public playoutHistoryCreate(playoutHistory: PlayoutHistory, options?: AxiosRequestConfig) {
        return PlayoutHistoryApiFp(this.configuration).playoutHistoryCreate(playoutHistory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryApi
     */
    public playoutHistoryDestroy(id: number, options?: AxiosRequestConfig) {
        return PlayoutHistoryApiFp(this.configuration).playoutHistoryDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryApi
     */
    public playoutHistoryList(options?: AxiosRequestConfig) {
        return PlayoutHistoryApiFp(this.configuration).playoutHistoryList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history.
     * @param {PatchedPlayoutHistory} [patchedPlayoutHistory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryApi
     */
    public playoutHistoryPartialUpdate(id: number, patchedPlayoutHistory?: PatchedPlayoutHistory, options?: AxiosRequestConfig) {
        return PlayoutHistoryApiFp(this.configuration).playoutHistoryPartialUpdate(id, patchedPlayoutHistory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryApi
     */
    public playoutHistoryRetrieve(id: number, options?: AxiosRequestConfig) {
        return PlayoutHistoryApiFp(this.configuration).playoutHistoryRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history.
     * @param {PlayoutHistory} playoutHistory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryApi
     */
    public playoutHistoryUpdate(id: number, playoutHistory: PlayoutHistory, options?: AxiosRequestConfig) {
        return PlayoutHistoryApiFp(this.configuration).playoutHistoryUpdate(id, playoutHistory, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayoutHistoryMetadataApi - axios parameter creator
 * @export
 */
export const PlayoutHistoryMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PlayoutHistoryMetadata} playoutHistoryMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataCreate: async (playoutHistoryMetadata: PlayoutHistoryMetadata, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playoutHistoryMetadata' is not null or undefined
            assertParamExists('playoutHistoryMetadataCreate', 'playoutHistoryMetadata', playoutHistoryMetadata)
            const localVarPath = `/api/v2/playout-history-metadata/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playoutHistoryMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryMetadataDestroy', 'id', id)
            const localVarPath = `/api/v2/playout-history-metadata/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/playout-history-metadata/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {PatchedPlayoutHistoryMetadata} [patchedPlayoutHistoryMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataPartialUpdate: async (id: number, patchedPlayoutHistoryMetadata?: PatchedPlayoutHistoryMetadata, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryMetadataPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/playout-history-metadata/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPlayoutHistoryMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryMetadataRetrieve', 'id', id)
            const localVarPath = `/api/v2/playout-history-metadata/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {PlayoutHistoryMetadata} playoutHistoryMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataUpdate: async (id: number, playoutHistoryMetadata: PlayoutHistoryMetadata, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryMetadataUpdate', 'id', id)
            // verify required parameter 'playoutHistoryMetadata' is not null or undefined
            assertParamExists('playoutHistoryMetadataUpdate', 'playoutHistoryMetadata', playoutHistoryMetadata)
            const localVarPath = `/api/v2/playout-history-metadata/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playoutHistoryMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayoutHistoryMetadataApi - functional programming interface
 * @export
 */
export const PlayoutHistoryMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayoutHistoryMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PlayoutHistoryMetadata} playoutHistoryMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryMetadataCreate(playoutHistoryMetadata: PlayoutHistoryMetadata, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryMetadataCreate(playoutHistoryMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryMetadataDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryMetadataDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryMetadataList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayoutHistoryMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryMetadataList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {PatchedPlayoutHistoryMetadata} [patchedPlayoutHistoryMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryMetadataPartialUpdate(id: number, patchedPlayoutHistoryMetadata?: PatchedPlayoutHistoryMetadata, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryMetadataPartialUpdate(id, patchedPlayoutHistoryMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryMetadataRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryMetadataRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {PlayoutHistoryMetadata} playoutHistoryMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryMetadataUpdate(id: number, playoutHistoryMetadata: PlayoutHistoryMetadata, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryMetadataUpdate(id, playoutHistoryMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayoutHistoryMetadataApi - factory interface
 * @export
 */
export const PlayoutHistoryMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayoutHistoryMetadataApiFp(configuration)
    return {
        /**
         * 
         * @param {PlayoutHistoryMetadata} playoutHistoryMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataCreate(playoutHistoryMetadata: PlayoutHistoryMetadata, options?: any): AxiosPromise<PlayoutHistoryMetadata> {
            return localVarFp.playoutHistoryMetadataCreate(playoutHistoryMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.playoutHistoryMetadataDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataList(options?: any): AxiosPromise<Array<PlayoutHistoryMetadata>> {
            return localVarFp.playoutHistoryMetadataList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {PatchedPlayoutHistoryMetadata} [patchedPlayoutHistoryMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataPartialUpdate(id: number, patchedPlayoutHistoryMetadata?: PatchedPlayoutHistoryMetadata, options?: any): AxiosPromise<PlayoutHistoryMetadata> {
            return localVarFp.playoutHistoryMetadataPartialUpdate(id, patchedPlayoutHistoryMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataRetrieve(id: number, options?: any): AxiosPromise<PlayoutHistoryMetadata> {
            return localVarFp.playoutHistoryMetadataRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history metadata.
         * @param {PlayoutHistoryMetadata} playoutHistoryMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryMetadataUpdate(id: number, playoutHistoryMetadata: PlayoutHistoryMetadata, options?: any): AxiosPromise<PlayoutHistoryMetadata> {
            return localVarFp.playoutHistoryMetadataUpdate(id, playoutHistoryMetadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayoutHistoryMetadataApi - object-oriented interface
 * @export
 * @class PlayoutHistoryMetadataApi
 * @extends {BaseAPI}
 */
export class PlayoutHistoryMetadataApi extends BaseAPI {
    /**
     * 
     * @param {PlayoutHistoryMetadata} playoutHistoryMetadata 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryMetadataApi
     */
    public playoutHistoryMetadataCreate(playoutHistoryMetadata: PlayoutHistoryMetadata, options?: AxiosRequestConfig) {
        return PlayoutHistoryMetadataApiFp(this.configuration).playoutHistoryMetadataCreate(playoutHistoryMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryMetadataApi
     */
    public playoutHistoryMetadataDestroy(id: number, options?: AxiosRequestConfig) {
        return PlayoutHistoryMetadataApiFp(this.configuration).playoutHistoryMetadataDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryMetadataApi
     */
    public playoutHistoryMetadataList(options?: AxiosRequestConfig) {
        return PlayoutHistoryMetadataApiFp(this.configuration).playoutHistoryMetadataList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history metadata.
     * @param {PatchedPlayoutHistoryMetadata} [patchedPlayoutHistoryMetadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryMetadataApi
     */
    public playoutHistoryMetadataPartialUpdate(id: number, patchedPlayoutHistoryMetadata?: PatchedPlayoutHistoryMetadata, options?: AxiosRequestConfig) {
        return PlayoutHistoryMetadataApiFp(this.configuration).playoutHistoryMetadataPartialUpdate(id, patchedPlayoutHistoryMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryMetadataApi
     */
    public playoutHistoryMetadataRetrieve(id: number, options?: AxiosRequestConfig) {
        return PlayoutHistoryMetadataApiFp(this.configuration).playoutHistoryMetadataRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history metadata.
     * @param {PlayoutHistoryMetadata} playoutHistoryMetadata 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryMetadataApi
     */
    public playoutHistoryMetadataUpdate(id: number, playoutHistoryMetadata: PlayoutHistoryMetadata, options?: AxiosRequestConfig) {
        return PlayoutHistoryMetadataApiFp(this.configuration).playoutHistoryMetadataUpdate(id, playoutHistoryMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayoutHistoryTemplateFieldsApi - axios parameter creator
 * @export
 */
export const PlayoutHistoryTemplateFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PlayoutHistoryTemplateField} playoutHistoryTemplateField 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsCreate: async (playoutHistoryTemplateField: PlayoutHistoryTemplateField, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playoutHistoryTemplateField' is not null or undefined
            assertParamExists('playoutHistoryTemplateFieldsCreate', 'playoutHistoryTemplateField', playoutHistoryTemplateField)
            const localVarPath = `/api/v2/playout-history-template-fields/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playoutHistoryTemplateField, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryTemplateFieldsDestroy', 'id', id)
            const localVarPath = `/api/v2/playout-history-template-fields/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/playout-history-template-fields/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {PatchedPlayoutHistoryTemplateField} [patchedPlayoutHistoryTemplateField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsPartialUpdate: async (id: number, patchedPlayoutHistoryTemplateField?: PatchedPlayoutHistoryTemplateField, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryTemplateFieldsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/playout-history-template-fields/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPlayoutHistoryTemplateField, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryTemplateFieldsRetrieve', 'id', id)
            const localVarPath = `/api/v2/playout-history-template-fields/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {PlayoutHistoryTemplateField} playoutHistoryTemplateField 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsUpdate: async (id: number, playoutHistoryTemplateField: PlayoutHistoryTemplateField, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryTemplateFieldsUpdate', 'id', id)
            // verify required parameter 'playoutHistoryTemplateField' is not null or undefined
            assertParamExists('playoutHistoryTemplateFieldsUpdate', 'playoutHistoryTemplateField', playoutHistoryTemplateField)
            const localVarPath = `/api/v2/playout-history-template-fields/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playoutHistoryTemplateField, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayoutHistoryTemplateFieldsApi - functional programming interface
 * @export
 */
export const PlayoutHistoryTemplateFieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayoutHistoryTemplateFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PlayoutHistoryTemplateField} playoutHistoryTemplateField 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplateFieldsCreate(playoutHistoryTemplateField: PlayoutHistoryTemplateField, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryTemplateField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplateFieldsCreate(playoutHistoryTemplateField, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplateFieldsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplateFieldsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplateFieldsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayoutHistoryTemplateField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplateFieldsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {PatchedPlayoutHistoryTemplateField} [patchedPlayoutHistoryTemplateField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplateFieldsPartialUpdate(id: number, patchedPlayoutHistoryTemplateField?: PatchedPlayoutHistoryTemplateField, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryTemplateField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplateFieldsPartialUpdate(id, patchedPlayoutHistoryTemplateField, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplateFieldsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryTemplateField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplateFieldsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {PlayoutHistoryTemplateField} playoutHistoryTemplateField 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplateFieldsUpdate(id: number, playoutHistoryTemplateField: PlayoutHistoryTemplateField, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryTemplateField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplateFieldsUpdate(id, playoutHistoryTemplateField, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayoutHistoryTemplateFieldsApi - factory interface
 * @export
 */
export const PlayoutHistoryTemplateFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayoutHistoryTemplateFieldsApiFp(configuration)
    return {
        /**
         * 
         * @param {PlayoutHistoryTemplateField} playoutHistoryTemplateField 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsCreate(playoutHistoryTemplateField: PlayoutHistoryTemplateField, options?: any): AxiosPromise<PlayoutHistoryTemplateField> {
            return localVarFp.playoutHistoryTemplateFieldsCreate(playoutHistoryTemplateField, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.playoutHistoryTemplateFieldsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsList(options?: any): AxiosPromise<Array<PlayoutHistoryTemplateField>> {
            return localVarFp.playoutHistoryTemplateFieldsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {PatchedPlayoutHistoryTemplateField} [patchedPlayoutHistoryTemplateField] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsPartialUpdate(id: number, patchedPlayoutHistoryTemplateField?: PatchedPlayoutHistoryTemplateField, options?: any): AxiosPromise<PlayoutHistoryTemplateField> {
            return localVarFp.playoutHistoryTemplateFieldsPartialUpdate(id, patchedPlayoutHistoryTemplateField, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsRetrieve(id: number, options?: any): AxiosPromise<PlayoutHistoryTemplateField> {
            return localVarFp.playoutHistoryTemplateFieldsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template field.
         * @param {PlayoutHistoryTemplateField} playoutHistoryTemplateField 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplateFieldsUpdate(id: number, playoutHistoryTemplateField: PlayoutHistoryTemplateField, options?: any): AxiosPromise<PlayoutHistoryTemplateField> {
            return localVarFp.playoutHistoryTemplateFieldsUpdate(id, playoutHistoryTemplateField, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayoutHistoryTemplateFieldsApi - object-oriented interface
 * @export
 * @class PlayoutHistoryTemplateFieldsApi
 * @extends {BaseAPI}
 */
export class PlayoutHistoryTemplateFieldsApi extends BaseAPI {
    /**
     * 
     * @param {PlayoutHistoryTemplateField} playoutHistoryTemplateField 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplateFieldsApi
     */
    public playoutHistoryTemplateFieldsCreate(playoutHistoryTemplateField: PlayoutHistoryTemplateField, options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplateFieldsApiFp(this.configuration).playoutHistoryTemplateFieldsCreate(playoutHistoryTemplateField, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history template field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplateFieldsApi
     */
    public playoutHistoryTemplateFieldsDestroy(id: number, options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplateFieldsApiFp(this.configuration).playoutHistoryTemplateFieldsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplateFieldsApi
     */
    public playoutHistoryTemplateFieldsList(options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplateFieldsApiFp(this.configuration).playoutHistoryTemplateFieldsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history template field.
     * @param {PatchedPlayoutHistoryTemplateField} [patchedPlayoutHistoryTemplateField] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplateFieldsApi
     */
    public playoutHistoryTemplateFieldsPartialUpdate(id: number, patchedPlayoutHistoryTemplateField?: PatchedPlayoutHistoryTemplateField, options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplateFieldsApiFp(this.configuration).playoutHistoryTemplateFieldsPartialUpdate(id, patchedPlayoutHistoryTemplateField, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history template field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplateFieldsApi
     */
    public playoutHistoryTemplateFieldsRetrieve(id: number, options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplateFieldsApiFp(this.configuration).playoutHistoryTemplateFieldsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history template field.
     * @param {PlayoutHistoryTemplateField} playoutHistoryTemplateField 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplateFieldsApi
     */
    public playoutHistoryTemplateFieldsUpdate(id: number, playoutHistoryTemplateField: PlayoutHistoryTemplateField, options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplateFieldsApiFp(this.configuration).playoutHistoryTemplateFieldsUpdate(id, playoutHistoryTemplateField, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayoutHistoryTemplatesApi - axios parameter creator
 * @export
 */
export const PlayoutHistoryTemplatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PlayoutHistoryTemplate} playoutHistoryTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesCreate: async (playoutHistoryTemplate: PlayoutHistoryTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playoutHistoryTemplate' is not null or undefined
            assertParamExists('playoutHistoryTemplatesCreate', 'playoutHistoryTemplate', playoutHistoryTemplate)
            const localVarPath = `/api/v2/playout-history-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playoutHistoryTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryTemplatesDestroy', 'id', id)
            const localVarPath = `/api/v2/playout-history-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/playout-history-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {PatchedPlayoutHistoryTemplate} [patchedPlayoutHistoryTemplate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesPartialUpdate: async (id: number, patchedPlayoutHistoryTemplate?: PatchedPlayoutHistoryTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryTemplatesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/playout-history-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPlayoutHistoryTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryTemplatesRetrieve', 'id', id)
            const localVarPath = `/api/v2/playout-history-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {PlayoutHistoryTemplate} playoutHistoryTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesUpdate: async (id: number, playoutHistoryTemplate: PlayoutHistoryTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playoutHistoryTemplatesUpdate', 'id', id)
            // verify required parameter 'playoutHistoryTemplate' is not null or undefined
            assertParamExists('playoutHistoryTemplatesUpdate', 'playoutHistoryTemplate', playoutHistoryTemplate)
            const localVarPath = `/api/v2/playout-history-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playoutHistoryTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayoutHistoryTemplatesApi - functional programming interface
 * @export
 */
export const PlayoutHistoryTemplatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayoutHistoryTemplatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PlayoutHistoryTemplate} playoutHistoryTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplatesCreate(playoutHistoryTemplate: PlayoutHistoryTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplatesCreate(playoutHistoryTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplatesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplatesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplatesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayoutHistoryTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplatesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {PatchedPlayoutHistoryTemplate} [patchedPlayoutHistoryTemplate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplatesPartialUpdate(id: number, patchedPlayoutHistoryTemplate?: PatchedPlayoutHistoryTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplatesPartialUpdate(id, patchedPlayoutHistoryTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplatesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplatesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {PlayoutHistoryTemplate} playoutHistoryTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playoutHistoryTemplatesUpdate(id: number, playoutHistoryTemplate: PlayoutHistoryTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayoutHistoryTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playoutHistoryTemplatesUpdate(id, playoutHistoryTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayoutHistoryTemplatesApi - factory interface
 * @export
 */
export const PlayoutHistoryTemplatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayoutHistoryTemplatesApiFp(configuration)
    return {
        /**
         * 
         * @param {PlayoutHistoryTemplate} playoutHistoryTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesCreate(playoutHistoryTemplate: PlayoutHistoryTemplate, options?: any): AxiosPromise<PlayoutHistoryTemplate> {
            return localVarFp.playoutHistoryTemplatesCreate(playoutHistoryTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.playoutHistoryTemplatesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesList(options?: any): AxiosPromise<Array<PlayoutHistoryTemplate>> {
            return localVarFp.playoutHistoryTemplatesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {PatchedPlayoutHistoryTemplate} [patchedPlayoutHistoryTemplate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesPartialUpdate(id: number, patchedPlayoutHistoryTemplate?: PatchedPlayoutHistoryTemplate, options?: any): AxiosPromise<PlayoutHistoryTemplate> {
            return localVarFp.playoutHistoryTemplatesPartialUpdate(id, patchedPlayoutHistoryTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesRetrieve(id: number, options?: any): AxiosPromise<PlayoutHistoryTemplate> {
            return localVarFp.playoutHistoryTemplatesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this playout history template.
         * @param {PlayoutHistoryTemplate} playoutHistoryTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playoutHistoryTemplatesUpdate(id: number, playoutHistoryTemplate: PlayoutHistoryTemplate, options?: any): AxiosPromise<PlayoutHistoryTemplate> {
            return localVarFp.playoutHistoryTemplatesUpdate(id, playoutHistoryTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayoutHistoryTemplatesApi - object-oriented interface
 * @export
 * @class PlayoutHistoryTemplatesApi
 * @extends {BaseAPI}
 */
export class PlayoutHistoryTemplatesApi extends BaseAPI {
    /**
     * 
     * @param {PlayoutHistoryTemplate} playoutHistoryTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplatesApi
     */
    public playoutHistoryTemplatesCreate(playoutHistoryTemplate: PlayoutHistoryTemplate, options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplatesApiFp(this.configuration).playoutHistoryTemplatesCreate(playoutHistoryTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplatesApi
     */
    public playoutHistoryTemplatesDestroy(id: number, options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplatesApiFp(this.configuration).playoutHistoryTemplatesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplatesApi
     */
    public playoutHistoryTemplatesList(options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplatesApiFp(this.configuration).playoutHistoryTemplatesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history template.
     * @param {PatchedPlayoutHistoryTemplate} [patchedPlayoutHistoryTemplate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplatesApi
     */
    public playoutHistoryTemplatesPartialUpdate(id: number, patchedPlayoutHistoryTemplate?: PatchedPlayoutHistoryTemplate, options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplatesApiFp(this.configuration).playoutHistoryTemplatesPartialUpdate(id, patchedPlayoutHistoryTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history template.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplatesApi
     */
    public playoutHistoryTemplatesRetrieve(id: number, options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplatesApiFp(this.configuration).playoutHistoryTemplatesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this playout history template.
     * @param {PlayoutHistoryTemplate} playoutHistoryTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayoutHistoryTemplatesApi
     */
    public playoutHistoryTemplatesUpdate(id: number, playoutHistoryTemplate: PlayoutHistoryTemplate, options?: AxiosRequestConfig) {
        return PlayoutHistoryTemplatesApiFp(this.configuration).playoutHistoryTemplatesUpdate(id, playoutHistoryTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PodcastEpisodesApi - axios parameter creator
 * @export
 */
export const PodcastEpisodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PodcastEpisode} podcastEpisode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesCreate: async (podcastEpisode: PodcastEpisode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'podcastEpisode' is not null or undefined
            assertParamExists('podcastEpisodesCreate', 'podcastEpisode', podcastEpisode)
            const localVarPath = `/api/v2/podcast-episodes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(podcastEpisode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('podcastEpisodesDestroy', 'id', id)
            const localVarPath = `/api/v2/podcast-episodes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/podcast-episodes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {PatchedPodcastEpisode} [patchedPodcastEpisode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesPartialUpdate: async (id: number, patchedPodcastEpisode?: PatchedPodcastEpisode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('podcastEpisodesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/podcast-episodes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPodcastEpisode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('podcastEpisodesRetrieve', 'id', id)
            const localVarPath = `/api/v2/podcast-episodes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {PodcastEpisode} podcastEpisode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesUpdate: async (id: number, podcastEpisode: PodcastEpisode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('podcastEpisodesUpdate', 'id', id)
            // verify required parameter 'podcastEpisode' is not null or undefined
            assertParamExists('podcastEpisodesUpdate', 'podcastEpisode', podcastEpisode)
            const localVarPath = `/api/v2/podcast-episodes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(podcastEpisode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PodcastEpisodesApi - functional programming interface
 * @export
 */
export const PodcastEpisodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PodcastEpisodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PodcastEpisode} podcastEpisode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastEpisodesCreate(podcastEpisode: PodcastEpisode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PodcastEpisode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastEpisodesCreate(podcastEpisode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastEpisodesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastEpisodesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastEpisodesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PodcastEpisode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastEpisodesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {PatchedPodcastEpisode} [patchedPodcastEpisode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastEpisodesPartialUpdate(id: number, patchedPodcastEpisode?: PatchedPodcastEpisode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PodcastEpisode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastEpisodesPartialUpdate(id, patchedPodcastEpisode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastEpisodesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PodcastEpisode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastEpisodesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {PodcastEpisode} podcastEpisode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastEpisodesUpdate(id: number, podcastEpisode: PodcastEpisode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PodcastEpisode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastEpisodesUpdate(id, podcastEpisode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PodcastEpisodesApi - factory interface
 * @export
 */
export const PodcastEpisodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PodcastEpisodesApiFp(configuration)
    return {
        /**
         * 
         * @param {PodcastEpisode} podcastEpisode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesCreate(podcastEpisode: PodcastEpisode, options?: any): AxiosPromise<PodcastEpisode> {
            return localVarFp.podcastEpisodesCreate(podcastEpisode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.podcastEpisodesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesList(options?: any): AxiosPromise<Array<PodcastEpisode>> {
            return localVarFp.podcastEpisodesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {PatchedPodcastEpisode} [patchedPodcastEpisode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesPartialUpdate(id: number, patchedPodcastEpisode?: PatchedPodcastEpisode, options?: any): AxiosPromise<PodcastEpisode> {
            return localVarFp.podcastEpisodesPartialUpdate(id, patchedPodcastEpisode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesRetrieve(id: number, options?: any): AxiosPromise<PodcastEpisode> {
            return localVarFp.podcastEpisodesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast episode.
         * @param {PodcastEpisode} podcastEpisode 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastEpisodesUpdate(id: number, podcastEpisode: PodcastEpisode, options?: any): AxiosPromise<PodcastEpisode> {
            return localVarFp.podcastEpisodesUpdate(id, podcastEpisode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PodcastEpisodesApi - object-oriented interface
 * @export
 * @class PodcastEpisodesApi
 * @extends {BaseAPI}
 */
export class PodcastEpisodesApi extends BaseAPI {
    /**
     * 
     * @param {PodcastEpisode} podcastEpisode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastEpisodesApi
     */
    public podcastEpisodesCreate(podcastEpisode: PodcastEpisode, options?: AxiosRequestConfig) {
        return PodcastEpisodesApiFp(this.configuration).podcastEpisodesCreate(podcastEpisode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this podcast episode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastEpisodesApi
     */
    public podcastEpisodesDestroy(id: number, options?: AxiosRequestConfig) {
        return PodcastEpisodesApiFp(this.configuration).podcastEpisodesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastEpisodesApi
     */
    public podcastEpisodesList(options?: AxiosRequestConfig) {
        return PodcastEpisodesApiFp(this.configuration).podcastEpisodesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this podcast episode.
     * @param {PatchedPodcastEpisode} [patchedPodcastEpisode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastEpisodesApi
     */
    public podcastEpisodesPartialUpdate(id: number, patchedPodcastEpisode?: PatchedPodcastEpisode, options?: AxiosRequestConfig) {
        return PodcastEpisodesApiFp(this.configuration).podcastEpisodesPartialUpdate(id, patchedPodcastEpisode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this podcast episode.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastEpisodesApi
     */
    public podcastEpisodesRetrieve(id: number, options?: AxiosRequestConfig) {
        return PodcastEpisodesApiFp(this.configuration).podcastEpisodesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this podcast episode.
     * @param {PodcastEpisode} podcastEpisode 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastEpisodesApi
     */
    public podcastEpisodesUpdate(id: number, podcastEpisode: PodcastEpisode, options?: AxiosRequestConfig) {
        return PodcastEpisodesApiFp(this.configuration).podcastEpisodesUpdate(id, podcastEpisode, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PodcastsApi - axios parameter creator
 * @export
 */
export const PodcastsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Podcast} podcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsCreate: async (podcast: Podcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'podcast' is not null or undefined
            assertParamExists('podcastsCreate', 'podcast', podcast)
            const localVarPath = `/api/v2/podcasts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(podcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('podcastsDestroy', 'id', id)
            const localVarPath = `/api/v2/podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/podcasts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {PatchedPodcast} [patchedPodcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsPartialUpdate: async (id: number, patchedPodcast?: PatchedPodcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('podcastsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPodcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('podcastsRetrieve', 'id', id)
            const localVarPath = `/api/v2/podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {Podcast} podcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsUpdate: async (id: number, podcast: Podcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('podcastsUpdate', 'id', id)
            // verify required parameter 'podcast' is not null or undefined
            assertParamExists('podcastsUpdate', 'podcast', podcast)
            const localVarPath = `/api/v2/podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(podcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PodcastsApi - functional programming interface
 * @export
 */
export const PodcastsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PodcastsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Podcast} podcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastsCreate(podcast: Podcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Podcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastsCreate(podcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Podcast>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {PatchedPodcast} [patchedPodcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastsPartialUpdate(id: number, patchedPodcast?: PatchedPodcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Podcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastsPartialUpdate(id, patchedPodcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Podcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {Podcast} podcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async podcastsUpdate(id: number, podcast: Podcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Podcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.podcastsUpdate(id, podcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PodcastsApi - factory interface
 * @export
 */
export const PodcastsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PodcastsApiFp(configuration)
    return {
        /**
         * 
         * @param {Podcast} podcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsCreate(podcast: Podcast, options?: any): AxiosPromise<Podcast> {
            return localVarFp.podcastsCreate(podcast, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.podcastsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsList(options?: any): AxiosPromise<Array<Podcast>> {
            return localVarFp.podcastsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {PatchedPodcast} [patchedPodcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsPartialUpdate(id: number, patchedPodcast?: PatchedPodcast, options?: any): AxiosPromise<Podcast> {
            return localVarFp.podcastsPartialUpdate(id, patchedPodcast, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsRetrieve(id: number, options?: any): AxiosPromise<Podcast> {
            return localVarFp.podcastsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this podcast.
         * @param {Podcast} podcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        podcastsUpdate(id: number, podcast: Podcast, options?: any): AxiosPromise<Podcast> {
            return localVarFp.podcastsUpdate(id, podcast, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PodcastsApi - object-oriented interface
 * @export
 * @class PodcastsApi
 * @extends {BaseAPI}
 */
export class PodcastsApi extends BaseAPI {
    /**
     * 
     * @param {Podcast} podcast 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsCreate(podcast: Podcast, options?: AxiosRequestConfig) {
        return PodcastsApiFp(this.configuration).podcastsCreate(podcast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this podcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsDestroy(id: number, options?: AxiosRequestConfig) {
        return PodcastsApiFp(this.configuration).podcastsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsList(options?: AxiosRequestConfig) {
        return PodcastsApiFp(this.configuration).podcastsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this podcast.
     * @param {PatchedPodcast} [patchedPodcast] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsPartialUpdate(id: number, patchedPodcast?: PatchedPodcast, options?: AxiosRequestConfig) {
        return PodcastsApiFp(this.configuration).podcastsPartialUpdate(id, patchedPodcast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this podcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsRetrieve(id: number, options?: AxiosRequestConfig) {
        return PodcastsApiFp(this.configuration).podcastsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this podcast.
     * @param {Podcast} podcast 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PodcastsApi
     */
    public podcastsUpdate(id: number, podcast: Podcast, options?: AxiosRequestConfig) {
        return PodcastsApiFp(this.configuration).podcastsUpdate(id, podcast, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PreferencesApi - axios parameter creator
 * @export
 */
export const PreferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Preference} preference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesCreate: async (preference: Preference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'preference' is not null or undefined
            assertParamExists('preferencesCreate', 'preference', preference)
            const localVarPath = `/api/v2/preferences/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('preferencesDestroy', 'id', id)
            const localVarPath = `/api/v2/preferences/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/preferences/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {PatchedPreference} [patchedPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesPartialUpdate: async (id: number, patchedPreference?: PatchedPreference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('preferencesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/preferences/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPreference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('preferencesRetrieve', 'id', id)
            const localVarPath = `/api/v2/preferences/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {Preference} preference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesUpdate: async (id: number, preference: Preference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('preferencesUpdate', 'id', id)
            // verify required parameter 'preference' is not null or undefined
            assertParamExists('preferencesUpdate', 'preference', preference)
            const localVarPath = `/api/v2/preferences/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(preference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PreferencesApi - functional programming interface
 * @export
 */
export const PreferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PreferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Preference} preference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async preferencesCreate(preference: Preference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Preference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.preferencesCreate(preference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async preferencesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.preferencesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async preferencesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Preference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.preferencesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {PatchedPreference} [patchedPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async preferencesPartialUpdate(id: number, patchedPreference?: PatchedPreference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Preference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.preferencesPartialUpdate(id, patchedPreference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async preferencesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Preference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.preferencesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {Preference} preference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async preferencesUpdate(id: number, preference: Preference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Preference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.preferencesUpdate(id, preference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PreferencesApi - factory interface
 * @export
 */
export const PreferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PreferencesApiFp(configuration)
    return {
        /**
         * 
         * @param {Preference} preference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesCreate(preference: Preference, options?: any): AxiosPromise<Preference> {
            return localVarFp.preferencesCreate(preference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.preferencesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesList(options?: any): AxiosPromise<Array<Preference>> {
            return localVarFp.preferencesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {PatchedPreference} [patchedPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesPartialUpdate(id: number, patchedPreference?: PatchedPreference, options?: any): AxiosPromise<Preference> {
            return localVarFp.preferencesPartialUpdate(id, patchedPreference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesRetrieve(id: number, options?: any): AxiosPromise<Preference> {
            return localVarFp.preferencesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this preference.
         * @param {Preference} preference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        preferencesUpdate(id: number, preference: Preference, options?: any): AxiosPromise<Preference> {
            return localVarFp.preferencesUpdate(id, preference, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PreferencesApi - object-oriented interface
 * @export
 * @class PreferencesApi
 * @extends {BaseAPI}
 */
export class PreferencesApi extends BaseAPI {
    /**
     * 
     * @param {Preference} preference 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    public preferencesCreate(preference: Preference, options?: AxiosRequestConfig) {
        return PreferencesApiFp(this.configuration).preferencesCreate(preference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this preference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    public preferencesDestroy(id: number, options?: AxiosRequestConfig) {
        return PreferencesApiFp(this.configuration).preferencesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    public preferencesList(options?: AxiosRequestConfig) {
        return PreferencesApiFp(this.configuration).preferencesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this preference.
     * @param {PatchedPreference} [patchedPreference] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    public preferencesPartialUpdate(id: number, patchedPreference?: PatchedPreference, options?: AxiosRequestConfig) {
        return PreferencesApiFp(this.configuration).preferencesPartialUpdate(id, patchedPreference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this preference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    public preferencesRetrieve(id: number, options?: AxiosRequestConfig) {
        return PreferencesApiFp(this.configuration).preferencesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this preference.
     * @param {Preference} preference 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PreferencesApi
     */
    public preferencesUpdate(id: number, preference: Preference, options?: AxiosRequestConfig) {
        return PreferencesApiFp(this.configuration).preferencesUpdate(id, preference, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ScheduleApi - axios parameter creator
 * @export
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Schedule} schedule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleCreate: async (schedule: Schedule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'schedule' is not null or undefined
            assertParamExists('scheduleCreate', 'schedule', schedule)
            const localVarPath = `/api/v2/schedule/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scheduleDestroy', 'id', id)
            const localVarPath = `/api/v2/schedule/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [broadcasted] 
         * @param {number} [broadcastedGt] 
         * @param {number} [broadcastedGte] 
         * @param {number} [broadcastedLt] 
         * @param {number} [broadcastedLte] 
         * @param {Array<number>} [broadcastedRange] Multiple values may be separated by commas.
         * @param {string} [ends] 
         * @param {string} [endsGt] 
         * @param {string} [endsGte] 
         * @param {string} [endsLt] 
         * @param {string} [endsLte] 
         * @param {Array<string>} [endsRange] Multiple values may be separated by commas.
         * @param {boolean} [isValid] Filter on valid instances
         * @param {number} [playoutStatus] 
         * @param {number} [playoutStatusGt] 
         * @param {number} [playoutStatusGte] 
         * @param {number} [playoutStatusLt] 
         * @param {number} [playoutStatusLte] 
         * @param {Array<number>} [playoutStatusRange] Multiple values may be separated by commas.
         * @param {string} [starts] 
         * @param {string} [startsGt] 
         * @param {string} [startsGte] 
         * @param {string} [startsLt] 
         * @param {string} [startsLte] 
         * @param {Array<string>} [startsRange] Multiple values may be separated by commas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleList: async (broadcasted?: number, broadcastedGt?: number, broadcastedGte?: number, broadcastedLt?: number, broadcastedLte?: number, broadcastedRange?: Array<number>, ends?: string, endsGt?: string, endsGte?: string, endsLt?: string, endsLte?: string, endsRange?: Array<string>, isValid?: boolean, playoutStatus?: number, playoutStatusGt?: number, playoutStatusGte?: number, playoutStatusLt?: number, playoutStatusLte?: number, playoutStatusRange?: Array<number>, starts?: string, startsGt?: string, startsGte?: string, startsLt?: string, startsLte?: string, startsRange?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/schedule/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (broadcasted !== undefined) {
                localVarQueryParameter['broadcasted'] = broadcasted;
            }

            if (broadcastedGt !== undefined) {
                localVarQueryParameter['broadcasted__gt'] = broadcastedGt;
            }

            if (broadcastedGte !== undefined) {
                localVarQueryParameter['broadcasted__gte'] = broadcastedGte;
            }

            if (broadcastedLt !== undefined) {
                localVarQueryParameter['broadcasted__lt'] = broadcastedLt;
            }

            if (broadcastedLte !== undefined) {
                localVarQueryParameter['broadcasted__lte'] = broadcastedLte;
            }

            if (broadcastedRange) {
                localVarQueryParameter['broadcasted__range'] = broadcastedRange.join(COLLECTION_FORMATS.csv);
            }

            if (ends !== undefined) {
                localVarQueryParameter['ends'] = (ends as any instanceof Date) ?
                    (ends as any).toISOString() :
                    ends;
            }

            if (endsGt !== undefined) {
                localVarQueryParameter['ends__gt'] = (endsGt as any instanceof Date) ?
                    (endsGt as any).toISOString() :
                    endsGt;
            }

            if (endsGte !== undefined) {
                localVarQueryParameter['ends__gte'] = (endsGte as any instanceof Date) ?
                    (endsGte as any).toISOString() :
                    endsGte;
            }

            if (endsLt !== undefined) {
                localVarQueryParameter['ends__lt'] = (endsLt as any instanceof Date) ?
                    (endsLt as any).toISOString() :
                    endsLt;
            }

            if (endsLte !== undefined) {
                localVarQueryParameter['ends__lte'] = (endsLte as any instanceof Date) ?
                    (endsLte as any).toISOString() :
                    endsLte;
            }

            if (endsRange) {
                localVarQueryParameter['ends__range'] = endsRange.join(COLLECTION_FORMATS.csv);
            }

            if (isValid !== undefined) {
                localVarQueryParameter['is_valid'] = isValid;
            }

            if (playoutStatus !== undefined) {
                localVarQueryParameter['playout_status'] = playoutStatus;
            }

            if (playoutStatusGt !== undefined) {
                localVarQueryParameter['playout_status__gt'] = playoutStatusGt;
            }

            if (playoutStatusGte !== undefined) {
                localVarQueryParameter['playout_status__gte'] = playoutStatusGte;
            }

            if (playoutStatusLt !== undefined) {
                localVarQueryParameter['playout_status__lt'] = playoutStatusLt;
            }

            if (playoutStatusLte !== undefined) {
                localVarQueryParameter['playout_status__lte'] = playoutStatusLte;
            }

            if (playoutStatusRange) {
                localVarQueryParameter['playout_status__range'] = playoutStatusRange.join(COLLECTION_FORMATS.csv);
            }

            if (starts !== undefined) {
                localVarQueryParameter['starts'] = (starts as any instanceof Date) ?
                    (starts as any).toISOString() :
                    starts;
            }

            if (startsGt !== undefined) {
                localVarQueryParameter['starts__gt'] = (startsGt as any instanceof Date) ?
                    (startsGt as any).toISOString() :
                    startsGt;
            }

            if (startsGte !== undefined) {
                localVarQueryParameter['starts__gte'] = (startsGte as any instanceof Date) ?
                    (startsGte as any).toISOString() :
                    startsGte;
            }

            if (startsLt !== undefined) {
                localVarQueryParameter['starts__lt'] = (startsLt as any instanceof Date) ?
                    (startsLt as any).toISOString() :
                    startsLt;
            }

            if (startsLte !== undefined) {
                localVarQueryParameter['starts__lte'] = (startsLte as any instanceof Date) ?
                    (startsLte as any).toISOString() :
                    startsLte;
            }

            if (startsRange) {
                localVarQueryParameter['starts__range'] = startsRange.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {PatchedSchedule} [patchedSchedule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePartialUpdate: async (id: number, patchedSchedule?: PatchedSchedule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('schedulePartialUpdate', 'id', id)
            const localVarPath = `/api/v2/schedule/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSchedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scheduleRetrieve', 'id', id)
            const localVarPath = `/api/v2/schedule/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {Schedule} schedule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleUpdate: async (id: number, schedule: Schedule, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('scheduleUpdate', 'id', id)
            // verify required parameter 'schedule' is not null or undefined
            assertParamExists('scheduleUpdate', 'schedule', schedule)
            const localVarPath = `/api/v2/schedule/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(schedule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Schedule} schedule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleCreate(schedule: Schedule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleCreate(schedule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [broadcasted] 
         * @param {number} [broadcastedGt] 
         * @param {number} [broadcastedGte] 
         * @param {number} [broadcastedLt] 
         * @param {number} [broadcastedLte] 
         * @param {Array<number>} [broadcastedRange] Multiple values may be separated by commas.
         * @param {string} [ends] 
         * @param {string} [endsGt] 
         * @param {string} [endsGte] 
         * @param {string} [endsLt] 
         * @param {string} [endsLte] 
         * @param {Array<string>} [endsRange] Multiple values may be separated by commas.
         * @param {boolean} [isValid] Filter on valid instances
         * @param {number} [playoutStatus] 
         * @param {number} [playoutStatusGt] 
         * @param {number} [playoutStatusGte] 
         * @param {number} [playoutStatusLt] 
         * @param {number} [playoutStatusLte] 
         * @param {Array<number>} [playoutStatusRange] Multiple values may be separated by commas.
         * @param {string} [starts] 
         * @param {string} [startsGt] 
         * @param {string} [startsGte] 
         * @param {string} [startsLt] 
         * @param {string} [startsLte] 
         * @param {Array<string>} [startsRange] Multiple values may be separated by commas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleList(broadcasted?: number, broadcastedGt?: number, broadcastedGte?: number, broadcastedLt?: number, broadcastedLte?: number, broadcastedRange?: Array<number>, ends?: string, endsGt?: string, endsGte?: string, endsLt?: string, endsLte?: string, endsRange?: Array<string>, isValid?: boolean, playoutStatus?: number, playoutStatusGt?: number, playoutStatusGte?: number, playoutStatusLt?: number, playoutStatusLte?: number, playoutStatusRange?: Array<number>, starts?: string, startsGt?: string, startsGte?: string, startsLt?: string, startsLte?: string, startsRange?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Schedule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleList(broadcasted, broadcastedGt, broadcastedGte, broadcastedLt, broadcastedLte, broadcastedRange, ends, endsGt, endsGte, endsLt, endsLte, endsRange, isValid, playoutStatus, playoutStatusGt, playoutStatusGte, playoutStatusLt, playoutStatusLte, playoutStatusRange, starts, startsGt, startsGte, startsLt, startsLte, startsRange, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {PatchedSchedule} [patchedSchedule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schedulePartialUpdate(id: number, patchedSchedule?: PatchedSchedule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schedulePartialUpdate(id, patchedSchedule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {Schedule} schedule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleUpdate(id: number, schedule: Schedule, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Schedule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleUpdate(id, schedule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         * 
         * @param {Schedule} schedule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleCreate(schedule: Schedule, options?: any): AxiosPromise<Schedule> {
            return localVarFp.scheduleCreate(schedule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.scheduleDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [broadcasted] 
         * @param {number} [broadcastedGt] 
         * @param {number} [broadcastedGte] 
         * @param {number} [broadcastedLt] 
         * @param {number} [broadcastedLte] 
         * @param {Array<number>} [broadcastedRange] Multiple values may be separated by commas.
         * @param {string} [ends] 
         * @param {string} [endsGt] 
         * @param {string} [endsGte] 
         * @param {string} [endsLt] 
         * @param {string} [endsLte] 
         * @param {Array<string>} [endsRange] Multiple values may be separated by commas.
         * @param {boolean} [isValid] Filter on valid instances
         * @param {number} [playoutStatus] 
         * @param {number} [playoutStatusGt] 
         * @param {number} [playoutStatusGte] 
         * @param {number} [playoutStatusLt] 
         * @param {number} [playoutStatusLte] 
         * @param {Array<number>} [playoutStatusRange] Multiple values may be separated by commas.
         * @param {string} [starts] 
         * @param {string} [startsGt] 
         * @param {string} [startsGte] 
         * @param {string} [startsLt] 
         * @param {string} [startsLte] 
         * @param {Array<string>} [startsRange] Multiple values may be separated by commas.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleList(broadcasted?: number, broadcastedGt?: number, broadcastedGte?: number, broadcastedLt?: number, broadcastedLte?: number, broadcastedRange?: Array<number>, ends?: string, endsGt?: string, endsGte?: string, endsLt?: string, endsLte?: string, endsRange?: Array<string>, isValid?: boolean, playoutStatus?: number, playoutStatusGt?: number, playoutStatusGte?: number, playoutStatusLt?: number, playoutStatusLte?: number, playoutStatusRange?: Array<number>, starts?: string, startsGt?: string, startsGte?: string, startsLt?: string, startsLte?: string, startsRange?: Array<string>, options?: any): AxiosPromise<Array<Schedule>> {
            return localVarFp.scheduleList(broadcasted, broadcastedGt, broadcastedGte, broadcastedLt, broadcastedLte, broadcastedRange, ends, endsGt, endsGte, endsLt, endsLte, endsRange, isValid, playoutStatus, playoutStatusGt, playoutStatusGte, playoutStatusLt, playoutStatusLte, playoutStatusRange, starts, startsGt, startsGte, startsLt, startsLte, startsRange, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {PatchedSchedule} [patchedSchedule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schedulePartialUpdate(id: number, patchedSchedule?: PatchedSchedule, options?: any): AxiosPromise<Schedule> {
            return localVarFp.schedulePartialUpdate(id, patchedSchedule, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleRetrieve(id: number, options?: any): AxiosPromise<Schedule> {
            return localVarFp.scheduleRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this schedule.
         * @param {Schedule} schedule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleUpdate(id: number, schedule: Schedule, options?: any): AxiosPromise<Schedule> {
            return localVarFp.scheduleUpdate(id, schedule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     * 
     * @param {Schedule} schedule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public scheduleCreate(schedule: Schedule, options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).scheduleCreate(schedule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this schedule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public scheduleDestroy(id: number, options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).scheduleDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [broadcasted] 
     * @param {number} [broadcastedGt] 
     * @param {number} [broadcastedGte] 
     * @param {number} [broadcastedLt] 
     * @param {number} [broadcastedLte] 
     * @param {Array<number>} [broadcastedRange] Multiple values may be separated by commas.
     * @param {string} [ends] 
     * @param {string} [endsGt] 
     * @param {string} [endsGte] 
     * @param {string} [endsLt] 
     * @param {string} [endsLte] 
     * @param {Array<string>} [endsRange] Multiple values may be separated by commas.
     * @param {boolean} [isValid] Filter on valid instances
     * @param {number} [playoutStatus] 
     * @param {number} [playoutStatusGt] 
     * @param {number} [playoutStatusGte] 
     * @param {number} [playoutStatusLt] 
     * @param {number} [playoutStatusLte] 
     * @param {Array<number>} [playoutStatusRange] Multiple values may be separated by commas.
     * @param {string} [starts] 
     * @param {string} [startsGt] 
     * @param {string} [startsGte] 
     * @param {string} [startsLt] 
     * @param {string} [startsLte] 
     * @param {Array<string>} [startsRange] Multiple values may be separated by commas.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public scheduleList(broadcasted?: number, broadcastedGt?: number, broadcastedGte?: number, broadcastedLt?: number, broadcastedLte?: number, broadcastedRange?: Array<number>, ends?: string, endsGt?: string, endsGte?: string, endsLt?: string, endsLte?: string, endsRange?: Array<string>, isValid?: boolean, playoutStatus?: number, playoutStatusGt?: number, playoutStatusGte?: number, playoutStatusLt?: number, playoutStatusLte?: number, playoutStatusRange?: Array<number>, starts?: string, startsGt?: string, startsGte?: string, startsLt?: string, startsLte?: string, startsRange?: Array<string>, options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).scheduleList(broadcasted, broadcastedGt, broadcastedGte, broadcastedLt, broadcastedLte, broadcastedRange, ends, endsGt, endsGte, endsLt, endsLte, endsRange, isValid, playoutStatus, playoutStatusGt, playoutStatusGte, playoutStatusLt, playoutStatusLte, playoutStatusRange, starts, startsGt, startsGte, startsLt, startsLte, startsRange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this schedule.
     * @param {PatchedSchedule} [patchedSchedule] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public schedulePartialUpdate(id: number, patchedSchedule?: PatchedSchedule, options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).schedulePartialUpdate(id, patchedSchedule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this schedule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public scheduleRetrieve(id: number, options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).scheduleRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this schedule.
     * @param {Schedule} schedule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public scheduleUpdate(id: number, schedule: Schedule, options?: AxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).scheduleUpdate(id, schedule, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaApi - axios parameter creator
 * @export
 */
export const SchemaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve: async (format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/schema/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaApi - functional programming interface
 * @export
 */
export const SchemaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaApiAxiosParamCreator(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async schemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.schemaRetrieve(format, lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaApi - factory interface
 * @export
 */
export const SchemaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaApiFp(configuration)
    return {
        /**
         * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
         * @param {'json' | 'yaml'} [format] 
         * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        schemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.schemaRetrieve(format, lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaApi - object-oriented interface
 * @export
 * @class SchemaApi
 * @extends {BaseAPI}
 */
export class SchemaApi extends BaseAPI {
    /**
     * OpenApi3 schema for this API. Format can be selected via content negotiation.  - YAML: application/vnd.oai.openapi - JSON: application/vnd.oai.openapi+json
     * @param {'json' | 'yaml'} [format] 
     * @param {'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant'} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaApi
     */
    public schemaRetrieve(format?: 'json' | 'yaml', lang?: 'af' | 'ar' | 'ar-dz' | 'ast' | 'az' | 'be' | 'bg' | 'bn' | 'br' | 'bs' | 'ca' | 'cs' | 'cy' | 'da' | 'de' | 'dsb' | 'el' | 'en' | 'en-au' | 'en-gb' | 'eo' | 'es' | 'es-ar' | 'es-co' | 'es-mx' | 'es-ni' | 'es-ve' | 'et' | 'eu' | 'fa' | 'fi' | 'fr' | 'fy' | 'ga' | 'gd' | 'gl' | 'he' | 'hi' | 'hr' | 'hsb' | 'hu' | 'hy' | 'ia' | 'id' | 'ig' | 'io' | 'is' | 'it' | 'ja' | 'ka' | 'kab' | 'kk' | 'km' | 'kn' | 'ko' | 'ky' | 'lb' | 'lt' | 'lv' | 'mk' | 'ml' | 'mn' | 'mr' | 'my' | 'nb' | 'ne' | 'nl' | 'nn' | 'os' | 'pa' | 'pl' | 'pt' | 'pt-br' | 'ro' | 'ru' | 'sk' | 'sl' | 'sq' | 'sr' | 'sr-latn' | 'sv' | 'sw' | 'ta' | 'te' | 'tg' | 'th' | 'tk' | 'tr' | 'tt' | 'udm' | 'uk' | 'ur' | 'uz' | 'vi' | 'zh-hans' | 'zh-hant', options?: AxiosRequestConfig) {
        return SchemaApiFp(this.configuration).schemaRetrieve(format, lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceRegistersApi - axios parameter creator
 * @export
 */
export const ServiceRegistersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServiceRegister} serviceRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersCreate: async (serviceRegister: ServiceRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceRegister' is not null or undefined
            assertParamExists('serviceRegistersCreate', 'serviceRegister', serviceRegister)
            const localVarPath = `/api/v2/service-registers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersDestroy: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('serviceRegistersDestroy', 'name', name)
            const localVarPath = `/api/v2/service-registers/{name}/`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/service-registers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {PatchedServiceRegister} [patchedServiceRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersPartialUpdate: async (name: string, patchedServiceRegister?: PatchedServiceRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('serviceRegistersPartialUpdate', 'name', name)
            const localVarPath = `/api/v2/service-registers/{name}/`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedServiceRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersRetrieve: async (name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('serviceRegistersRetrieve', 'name', name)
            const localVarPath = `/api/v2/service-registers/{name}/`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {ServiceRegister} serviceRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersUpdate: async (name: string, serviceRegister: ServiceRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('serviceRegistersUpdate', 'name', name)
            // verify required parameter 'serviceRegister' is not null or undefined
            assertParamExists('serviceRegistersUpdate', 'serviceRegister', serviceRegister)
            const localVarPath = `/api/v2/service-registers/{name}/`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceRegistersApi - functional programming interface
 * @export
 */
export const ServiceRegistersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceRegistersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ServiceRegister} serviceRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceRegistersCreate(serviceRegister: ServiceRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRegister>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceRegistersCreate(serviceRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceRegistersDestroy(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceRegistersDestroy(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceRegistersList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceRegister>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceRegistersList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {PatchedServiceRegister} [patchedServiceRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceRegistersPartialUpdate(name: string, patchedServiceRegister?: PatchedServiceRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRegister>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceRegistersPartialUpdate(name, patchedServiceRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceRegistersRetrieve(name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRegister>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceRegistersRetrieve(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {ServiceRegister} serviceRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceRegistersUpdate(name: string, serviceRegister: ServiceRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceRegister>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceRegistersUpdate(name, serviceRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceRegistersApi - factory interface
 * @export
 */
export const ServiceRegistersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceRegistersApiFp(configuration)
    return {
        /**
         * 
         * @param {ServiceRegister} serviceRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersCreate(serviceRegister: ServiceRegister, options?: any): AxiosPromise<ServiceRegister> {
            return localVarFp.serviceRegistersCreate(serviceRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersDestroy(name: string, options?: any): AxiosPromise<void> {
            return localVarFp.serviceRegistersDestroy(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersList(options?: any): AxiosPromise<Array<ServiceRegister>> {
            return localVarFp.serviceRegistersList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {PatchedServiceRegister} [patchedServiceRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersPartialUpdate(name: string, patchedServiceRegister?: PatchedServiceRegister, options?: any): AxiosPromise<ServiceRegister> {
            return localVarFp.serviceRegistersPartialUpdate(name, patchedServiceRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersRetrieve(name: string, options?: any): AxiosPromise<ServiceRegister> {
            return localVarFp.serviceRegistersRetrieve(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name A unique value identifying this service register.
         * @param {ServiceRegister} serviceRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceRegistersUpdate(name: string, serviceRegister: ServiceRegister, options?: any): AxiosPromise<ServiceRegister> {
            return localVarFp.serviceRegistersUpdate(name, serviceRegister, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceRegistersApi - object-oriented interface
 * @export
 * @class ServiceRegistersApi
 * @extends {BaseAPI}
 */
export class ServiceRegistersApi extends BaseAPI {
    /**
     * 
     * @param {ServiceRegister} serviceRegister 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceRegistersApi
     */
    public serviceRegistersCreate(serviceRegister: ServiceRegister, options?: AxiosRequestConfig) {
        return ServiceRegistersApiFp(this.configuration).serviceRegistersCreate(serviceRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name A unique value identifying this service register.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceRegistersApi
     */
    public serviceRegistersDestroy(name: string, options?: AxiosRequestConfig) {
        return ServiceRegistersApiFp(this.configuration).serviceRegistersDestroy(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceRegistersApi
     */
    public serviceRegistersList(options?: AxiosRequestConfig) {
        return ServiceRegistersApiFp(this.configuration).serviceRegistersList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name A unique value identifying this service register.
     * @param {PatchedServiceRegister} [patchedServiceRegister] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceRegistersApi
     */
    public serviceRegistersPartialUpdate(name: string, patchedServiceRegister?: PatchedServiceRegister, options?: AxiosRequestConfig) {
        return ServiceRegistersApiFp(this.configuration).serviceRegistersPartialUpdate(name, patchedServiceRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name A unique value identifying this service register.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceRegistersApi
     */
    public serviceRegistersRetrieve(name: string, options?: AxiosRequestConfig) {
        return ServiceRegistersApiFp(this.configuration).serviceRegistersRetrieve(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name A unique value identifying this service register.
     * @param {ServiceRegister} serviceRegister 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceRegistersApi
     */
    public serviceRegistersUpdate(name: string, serviceRegister: ServiceRegister, options?: AxiosRequestConfig) {
        return ServiceRegistersApiFp(this.configuration).serviceRegistersUpdate(name, serviceRegister, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SessionsApi - axios parameter creator
 * @export
 */
export const SessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Session} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsCreate: async (session?: Session, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(session, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsDestroy: async (sessid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessid' is not null or undefined
            assertParamExists('sessionsDestroy', 'sessid', sessid)
            const localVarPath = `/api/v2/sessions/{sessid}/`
                .replace(`{${"sessid"}}`, encodeURIComponent(String(sessid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/sessions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {PatchedSession} [patchedSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsPartialUpdate: async (sessid: string, patchedSession?: PatchedSession, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessid' is not null or undefined
            assertParamExists('sessionsPartialUpdate', 'sessid', sessid)
            const localVarPath = `/api/v2/sessions/{sessid}/`
                .replace(`{${"sessid"}}`, encodeURIComponent(String(sessid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSession, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsRetrieve: async (sessid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessid' is not null or undefined
            assertParamExists('sessionsRetrieve', 'sessid', sessid)
            const localVarPath = `/api/v2/sessions/{sessid}/`
                .replace(`{${"sessid"}}`, encodeURIComponent(String(sessid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {Session} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsUpdate: async (sessid: string, session?: Session, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessid' is not null or undefined
            assertParamExists('sessionsUpdate', 'sessid', sessid)
            const localVarPath = `/api/v2/sessions/{sessid}/`
                .replace(`{${"sessid"}}`, encodeURIComponent(String(sessid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(session, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionsApi - functional programming interface
 * @export
 */
export const SessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Session} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsCreate(session?: Session, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsCreate(session, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsDestroy(sessid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsDestroy(sessid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Session>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {PatchedSession} [patchedSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsPartialUpdate(sessid: string, patchedSession?: PatchedSession, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsPartialUpdate(sessid, patchedSession, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsRetrieve(sessid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsRetrieve(sessid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {Session} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sessionsUpdate(sessid: string, session?: Session, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Session>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sessionsUpdate(sessid, session, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SessionsApi - factory interface
 * @export
 */
export const SessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionsApiFp(configuration)
    return {
        /**
         * 
         * @param {Session} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsCreate(session?: Session, options?: any): AxiosPromise<Session> {
            return localVarFp.sessionsCreate(session, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsDestroy(sessid: string, options?: any): AxiosPromise<void> {
            return localVarFp.sessionsDestroy(sessid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsList(options?: any): AxiosPromise<Array<Session>> {
            return localVarFp.sessionsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {PatchedSession} [patchedSession] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsPartialUpdate(sessid: string, patchedSession?: PatchedSession, options?: any): AxiosPromise<Session> {
            return localVarFp.sessionsPartialUpdate(sessid, patchedSession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsRetrieve(sessid: string, options?: any): AxiosPromise<Session> {
            return localVarFp.sessionsRetrieve(sessid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sessid A unique value identifying this session.
         * @param {Session} [session] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sessionsUpdate(sessid: string, session?: Session, options?: any): AxiosPromise<Session> {
            return localVarFp.sessionsUpdate(sessid, session, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionsApi - object-oriented interface
 * @export
 * @class SessionsApi
 * @extends {BaseAPI}
 */
export class SessionsApi extends BaseAPI {
    /**
     * 
     * @param {Session} [session] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionsCreate(session?: Session, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).sessionsCreate(session, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessid A unique value identifying this session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionsDestroy(sessid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).sessionsDestroy(sessid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionsList(options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).sessionsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessid A unique value identifying this session.
     * @param {PatchedSession} [patchedSession] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionsPartialUpdate(sessid: string, patchedSession?: PatchedSession, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).sessionsPartialUpdate(sessid, patchedSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessid A unique value identifying this session.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionsRetrieve(sessid: string, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).sessionsRetrieve(sessid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sessid A unique value identifying this session.
     * @param {Session} [session] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionsApi
     */
    public sessionsUpdate(sessid: string, session?: Session, options?: AxiosRequestConfig) {
        return SessionsApiFp(this.configuration).sessionsUpdate(sessid, session, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShowDaysApi - axios parameter creator
 * @export
 */
export const ShowDaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ShowDays} showDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysCreate: async (showDays: ShowDays, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'showDays' is not null or undefined
            assertParamExists('showDaysCreate', 'showDays', showDays)
            const localVarPath = `/api/v2/show-days/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(showDays, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showDaysDestroy', 'id', id)
            const localVarPath = `/api/v2/show-days/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/show-days/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {PatchedShowDays} [patchedShowDays] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysPartialUpdate: async (id: number, patchedShowDays?: PatchedShowDays, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showDaysPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/show-days/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShowDays, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showDaysRetrieve', 'id', id)
            const localVarPath = `/api/v2/show-days/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {ShowDays} showDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysUpdate: async (id: number, showDays: ShowDays, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showDaysUpdate', 'id', id)
            // verify required parameter 'showDays' is not null or undefined
            assertParamExists('showDaysUpdate', 'showDays', showDays)
            const localVarPath = `/api/v2/show-days/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(showDays, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShowDaysApi - functional programming interface
 * @export
 */
export const ShowDaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShowDaysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ShowDays} showDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showDaysCreate(showDays: ShowDays, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowDays>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showDaysCreate(showDays, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showDaysDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showDaysDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showDaysList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShowDays>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showDaysList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {PatchedShowDays} [patchedShowDays] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showDaysPartialUpdate(id: number, patchedShowDays?: PatchedShowDays, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowDays>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showDaysPartialUpdate(id, patchedShowDays, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showDaysRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowDays>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showDaysRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {ShowDays} showDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showDaysUpdate(id: number, showDays: ShowDays, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowDays>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showDaysUpdate(id, showDays, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShowDaysApi - factory interface
 * @export
 */
export const ShowDaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShowDaysApiFp(configuration)
    return {
        /**
         * 
         * @param {ShowDays} showDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysCreate(showDays: ShowDays, options?: any): AxiosPromise<ShowDays> {
            return localVarFp.showDaysCreate(showDays, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.showDaysDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysList(options?: any): AxiosPromise<Array<ShowDays>> {
            return localVarFp.showDaysList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {PatchedShowDays} [patchedShowDays] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysPartialUpdate(id: number, patchedShowDays?: PatchedShowDays, options?: any): AxiosPromise<ShowDays> {
            return localVarFp.showDaysPartialUpdate(id, patchedShowDays, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysRetrieve(id: number, options?: any): AxiosPromise<ShowDays> {
            return localVarFp.showDaysRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show days.
         * @param {ShowDays} showDays 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showDaysUpdate(id: number, showDays: ShowDays, options?: any): AxiosPromise<ShowDays> {
            return localVarFp.showDaysUpdate(id, showDays, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShowDaysApi - object-oriented interface
 * @export
 * @class ShowDaysApi
 * @extends {BaseAPI}
 */
export class ShowDaysApi extends BaseAPI {
    /**
     * 
     * @param {ShowDays} showDays 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowDaysApi
     */
    public showDaysCreate(showDays: ShowDays, options?: AxiosRequestConfig) {
        return ShowDaysApiFp(this.configuration).showDaysCreate(showDays, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show days.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowDaysApi
     */
    public showDaysDestroy(id: number, options?: AxiosRequestConfig) {
        return ShowDaysApiFp(this.configuration).showDaysDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowDaysApi
     */
    public showDaysList(options?: AxiosRequestConfig) {
        return ShowDaysApiFp(this.configuration).showDaysList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show days.
     * @param {PatchedShowDays} [patchedShowDays] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowDaysApi
     */
    public showDaysPartialUpdate(id: number, patchedShowDays?: PatchedShowDays, options?: AxiosRequestConfig) {
        return ShowDaysApiFp(this.configuration).showDaysPartialUpdate(id, patchedShowDays, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show days.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowDaysApi
     */
    public showDaysRetrieve(id: number, options?: AxiosRequestConfig) {
        return ShowDaysApiFp(this.configuration).showDaysRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show days.
     * @param {ShowDays} showDays 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowDaysApi
     */
    public showDaysUpdate(id: number, showDays: ShowDays, options?: AxiosRequestConfig) {
        return ShowDaysApiFp(this.configuration).showDaysUpdate(id, showDays, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShowHostsApi - axios parameter creator
 * @export
 */
export const ShowHostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ShowHost} showHost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsCreate: async (showHost: ShowHost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'showHost' is not null or undefined
            assertParamExists('showHostsCreate', 'showHost', showHost)
            const localVarPath = `/api/v2/show-hosts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(showHost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showHostsDestroy', 'id', id)
            const localVarPath = `/api/v2/show-hosts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/show-hosts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {PatchedShowHost} [patchedShowHost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsPartialUpdate: async (id: number, patchedShowHost?: PatchedShowHost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showHostsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/show-hosts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShowHost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showHostsRetrieve', 'id', id)
            const localVarPath = `/api/v2/show-hosts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {ShowHost} showHost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsUpdate: async (id: number, showHost: ShowHost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showHostsUpdate', 'id', id)
            // verify required parameter 'showHost' is not null or undefined
            assertParamExists('showHostsUpdate', 'showHost', showHost)
            const localVarPath = `/api/v2/show-hosts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(showHost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShowHostsApi - functional programming interface
 * @export
 */
export const ShowHostsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShowHostsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ShowHost} showHost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showHostsCreate(showHost: ShowHost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowHost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showHostsCreate(showHost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showHostsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showHostsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showHostsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShowHost>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showHostsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {PatchedShowHost} [patchedShowHost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showHostsPartialUpdate(id: number, patchedShowHost?: PatchedShowHost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowHost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showHostsPartialUpdate(id, patchedShowHost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showHostsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowHost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showHostsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {ShowHost} showHost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showHostsUpdate(id: number, showHost: ShowHost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowHost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showHostsUpdate(id, showHost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShowHostsApi - factory interface
 * @export
 */
export const ShowHostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShowHostsApiFp(configuration)
    return {
        /**
         * 
         * @param {ShowHost} showHost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsCreate(showHost: ShowHost, options?: any): AxiosPromise<ShowHost> {
            return localVarFp.showHostsCreate(showHost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.showHostsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsList(options?: any): AxiosPromise<Array<ShowHost>> {
            return localVarFp.showHostsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {PatchedShowHost} [patchedShowHost] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsPartialUpdate(id: number, patchedShowHost?: PatchedShowHost, options?: any): AxiosPromise<ShowHost> {
            return localVarFp.showHostsPartialUpdate(id, patchedShowHost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsRetrieve(id: number, options?: any): AxiosPromise<ShowHost> {
            return localVarFp.showHostsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show host.
         * @param {ShowHost} showHost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showHostsUpdate(id: number, showHost: ShowHost, options?: any): AxiosPromise<ShowHost> {
            return localVarFp.showHostsUpdate(id, showHost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShowHostsApi - object-oriented interface
 * @export
 * @class ShowHostsApi
 * @extends {BaseAPI}
 */
export class ShowHostsApi extends BaseAPI {
    /**
     * 
     * @param {ShowHost} showHost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowHostsApi
     */
    public showHostsCreate(showHost: ShowHost, options?: AxiosRequestConfig) {
        return ShowHostsApiFp(this.configuration).showHostsCreate(showHost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show host.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowHostsApi
     */
    public showHostsDestroy(id: number, options?: AxiosRequestConfig) {
        return ShowHostsApiFp(this.configuration).showHostsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowHostsApi
     */
    public showHostsList(options?: AxiosRequestConfig) {
        return ShowHostsApiFp(this.configuration).showHostsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show host.
     * @param {PatchedShowHost} [patchedShowHost] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowHostsApi
     */
    public showHostsPartialUpdate(id: number, patchedShowHost?: PatchedShowHost, options?: AxiosRequestConfig) {
        return ShowHostsApiFp(this.configuration).showHostsPartialUpdate(id, patchedShowHost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show host.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowHostsApi
     */
    public showHostsRetrieve(id: number, options?: AxiosRequestConfig) {
        return ShowHostsApiFp(this.configuration).showHostsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show host.
     * @param {ShowHost} showHost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowHostsApi
     */
    public showHostsUpdate(id: number, showHost: ShowHost, options?: AxiosRequestConfig) {
        return ShowHostsApiFp(this.configuration).showHostsUpdate(id, showHost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShowInstancesApi - axios parameter creator
 * @export
 */
export const ShowInstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ShowInstance} showInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesCreate: async (showInstance: ShowInstance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'showInstance' is not null or undefined
            assertParamExists('showInstancesCreate', 'showInstance', showInstance)
            const localVarPath = `/api/v2/show-instances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(showInstance, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showInstancesDestroy', 'id', id)
            const localVarPath = `/api/v2/show-instances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/show-instances/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {PatchedShowInstance} [patchedShowInstance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesPartialUpdate: async (id: number, patchedShowInstance?: PatchedShowInstance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showInstancesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/show-instances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShowInstance, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showInstancesRetrieve', 'id', id)
            const localVarPath = `/api/v2/show-instances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {ShowInstance} showInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesUpdate: async (id: number, showInstance: ShowInstance, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showInstancesUpdate', 'id', id)
            // verify required parameter 'showInstance' is not null or undefined
            assertParamExists('showInstancesUpdate', 'showInstance', showInstance)
            const localVarPath = `/api/v2/show-instances/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(showInstance, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShowInstancesApi - functional programming interface
 * @export
 */
export const ShowInstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShowInstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ShowInstance} showInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showInstancesCreate(showInstance: ShowInstance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showInstancesCreate(showInstance, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showInstancesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showInstancesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showInstancesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShowInstance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showInstancesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {PatchedShowInstance} [patchedShowInstance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showInstancesPartialUpdate(id: number, patchedShowInstance?: PatchedShowInstance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showInstancesPartialUpdate(id, patchedShowInstance, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showInstancesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showInstancesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {ShowInstance} showInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showInstancesUpdate(id: number, showInstance: ShowInstance, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowInstance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showInstancesUpdate(id, showInstance, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShowInstancesApi - factory interface
 * @export
 */
export const ShowInstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShowInstancesApiFp(configuration)
    return {
        /**
         * 
         * @param {ShowInstance} showInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesCreate(showInstance: ShowInstance, options?: any): AxiosPromise<ShowInstance> {
            return localVarFp.showInstancesCreate(showInstance, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.showInstancesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesList(options?: any): AxiosPromise<Array<ShowInstance>> {
            return localVarFp.showInstancesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {PatchedShowInstance} [patchedShowInstance] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesPartialUpdate(id: number, patchedShowInstance?: PatchedShowInstance, options?: any): AxiosPromise<ShowInstance> {
            return localVarFp.showInstancesPartialUpdate(id, patchedShowInstance, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesRetrieve(id: number, options?: any): AxiosPromise<ShowInstance> {
            return localVarFp.showInstancesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show instance.
         * @param {ShowInstance} showInstance 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showInstancesUpdate(id: number, showInstance: ShowInstance, options?: any): AxiosPromise<ShowInstance> {
            return localVarFp.showInstancesUpdate(id, showInstance, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShowInstancesApi - object-oriented interface
 * @export
 * @class ShowInstancesApi
 * @extends {BaseAPI}
 */
export class ShowInstancesApi extends BaseAPI {
    /**
     * 
     * @param {ShowInstance} showInstance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowInstancesApi
     */
    public showInstancesCreate(showInstance: ShowInstance, options?: AxiosRequestConfig) {
        return ShowInstancesApiFp(this.configuration).showInstancesCreate(showInstance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show instance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowInstancesApi
     */
    public showInstancesDestroy(id: number, options?: AxiosRequestConfig) {
        return ShowInstancesApiFp(this.configuration).showInstancesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowInstancesApi
     */
    public showInstancesList(options?: AxiosRequestConfig) {
        return ShowInstancesApiFp(this.configuration).showInstancesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show instance.
     * @param {PatchedShowInstance} [patchedShowInstance] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowInstancesApi
     */
    public showInstancesPartialUpdate(id: number, patchedShowInstance?: PatchedShowInstance, options?: AxiosRequestConfig) {
        return ShowInstancesApiFp(this.configuration).showInstancesPartialUpdate(id, patchedShowInstance, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show instance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowInstancesApi
     */
    public showInstancesRetrieve(id: number, options?: AxiosRequestConfig) {
        return ShowInstancesApiFp(this.configuration).showInstancesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show instance.
     * @param {ShowInstance} showInstance 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowInstancesApi
     */
    public showInstancesUpdate(id: number, showInstance: ShowInstance, options?: AxiosRequestConfig) {
        return ShowInstancesApiFp(this.configuration).showInstancesUpdate(id, showInstance, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShowRebroadcastsApi - axios parameter creator
 * @export
 */
export const ShowRebroadcastsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ShowRebroadcast} showRebroadcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsCreate: async (showRebroadcast: ShowRebroadcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'showRebroadcast' is not null or undefined
            assertParamExists('showRebroadcastsCreate', 'showRebroadcast', showRebroadcast)
            const localVarPath = `/api/v2/show-rebroadcasts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(showRebroadcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showRebroadcastsDestroy', 'id', id)
            const localVarPath = `/api/v2/show-rebroadcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/show-rebroadcasts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {PatchedShowRebroadcast} [patchedShowRebroadcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsPartialUpdate: async (id: number, patchedShowRebroadcast?: PatchedShowRebroadcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showRebroadcastsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/show-rebroadcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShowRebroadcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showRebroadcastsRetrieve', 'id', id)
            const localVarPath = `/api/v2/show-rebroadcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {ShowRebroadcast} showRebroadcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsUpdate: async (id: number, showRebroadcast: ShowRebroadcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showRebroadcastsUpdate', 'id', id)
            // verify required parameter 'showRebroadcast' is not null or undefined
            assertParamExists('showRebroadcastsUpdate', 'showRebroadcast', showRebroadcast)
            const localVarPath = `/api/v2/show-rebroadcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(showRebroadcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShowRebroadcastsApi - functional programming interface
 * @export
 */
export const ShowRebroadcastsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShowRebroadcastsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ShowRebroadcast} showRebroadcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showRebroadcastsCreate(showRebroadcast: ShowRebroadcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowRebroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showRebroadcastsCreate(showRebroadcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showRebroadcastsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showRebroadcastsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showRebroadcastsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ShowRebroadcast>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showRebroadcastsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {PatchedShowRebroadcast} [patchedShowRebroadcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showRebroadcastsPartialUpdate(id: number, patchedShowRebroadcast?: PatchedShowRebroadcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowRebroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showRebroadcastsPartialUpdate(id, patchedShowRebroadcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showRebroadcastsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowRebroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showRebroadcastsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {ShowRebroadcast} showRebroadcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showRebroadcastsUpdate(id: number, showRebroadcast: ShowRebroadcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShowRebroadcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showRebroadcastsUpdate(id, showRebroadcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShowRebroadcastsApi - factory interface
 * @export
 */
export const ShowRebroadcastsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShowRebroadcastsApiFp(configuration)
    return {
        /**
         * 
         * @param {ShowRebroadcast} showRebroadcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsCreate(showRebroadcast: ShowRebroadcast, options?: any): AxiosPromise<ShowRebroadcast> {
            return localVarFp.showRebroadcastsCreate(showRebroadcast, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.showRebroadcastsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsList(options?: any): AxiosPromise<Array<ShowRebroadcast>> {
            return localVarFp.showRebroadcastsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {PatchedShowRebroadcast} [patchedShowRebroadcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsPartialUpdate(id: number, patchedShowRebroadcast?: PatchedShowRebroadcast, options?: any): AxiosPromise<ShowRebroadcast> {
            return localVarFp.showRebroadcastsPartialUpdate(id, patchedShowRebroadcast, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsRetrieve(id: number, options?: any): AxiosPromise<ShowRebroadcast> {
            return localVarFp.showRebroadcastsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show rebroadcast.
         * @param {ShowRebroadcast} showRebroadcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showRebroadcastsUpdate(id: number, showRebroadcast: ShowRebroadcast, options?: any): AxiosPromise<ShowRebroadcast> {
            return localVarFp.showRebroadcastsUpdate(id, showRebroadcast, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShowRebroadcastsApi - object-oriented interface
 * @export
 * @class ShowRebroadcastsApi
 * @extends {BaseAPI}
 */
export class ShowRebroadcastsApi extends BaseAPI {
    /**
     * 
     * @param {ShowRebroadcast} showRebroadcast 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowRebroadcastsApi
     */
    public showRebroadcastsCreate(showRebroadcast: ShowRebroadcast, options?: AxiosRequestConfig) {
        return ShowRebroadcastsApiFp(this.configuration).showRebroadcastsCreate(showRebroadcast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show rebroadcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowRebroadcastsApi
     */
    public showRebroadcastsDestroy(id: number, options?: AxiosRequestConfig) {
        return ShowRebroadcastsApiFp(this.configuration).showRebroadcastsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowRebroadcastsApi
     */
    public showRebroadcastsList(options?: AxiosRequestConfig) {
        return ShowRebroadcastsApiFp(this.configuration).showRebroadcastsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show rebroadcast.
     * @param {PatchedShowRebroadcast} [patchedShowRebroadcast] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowRebroadcastsApi
     */
    public showRebroadcastsPartialUpdate(id: number, patchedShowRebroadcast?: PatchedShowRebroadcast, options?: AxiosRequestConfig) {
        return ShowRebroadcastsApiFp(this.configuration).showRebroadcastsPartialUpdate(id, patchedShowRebroadcast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show rebroadcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowRebroadcastsApi
     */
    public showRebroadcastsRetrieve(id: number, options?: AxiosRequestConfig) {
        return ShowRebroadcastsApiFp(this.configuration).showRebroadcastsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show rebroadcast.
     * @param {ShowRebroadcast} showRebroadcast 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowRebroadcastsApi
     */
    public showRebroadcastsUpdate(id: number, showRebroadcast: ShowRebroadcast, options?: AxiosRequestConfig) {
        return ShowRebroadcastsApiFp(this.configuration).showRebroadcastsUpdate(id, showRebroadcast, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShowsApi - axios parameter creator
 * @export
 */
export const ShowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Show} show 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsCreate: async (show: Show, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'show' is not null or undefined
            assertParamExists('showsCreate', 'show', show)
            const localVarPath = `/api/v2/shows/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(show, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showsDestroy', 'id', id)
            const localVarPath = `/api/v2/shows/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/shows/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {PatchedShow} [patchedShow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsPartialUpdate: async (id: number, patchedShow?: PatchedShow, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/shows/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShow, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showsRetrieve', 'id', id)
            const localVarPath = `/api/v2/shows/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {Show} show 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsUpdate: async (id: number, show: Show, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('showsUpdate', 'id', id)
            // verify required parameter 'show' is not null or undefined
            assertParamExists('showsUpdate', 'show', show)
            const localVarPath = `/api/v2/shows/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(show, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShowsApi - functional programming interface
 * @export
 */
export const ShowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShowsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Show} show 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showsCreate(show: Show, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Show>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showsCreate(show, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Show>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {PatchedShow} [patchedShow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showsPartialUpdate(id: number, patchedShow?: PatchedShow, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Show>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showsPartialUpdate(id, patchedShow, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Show>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {Show} show 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async showsUpdate(id: number, show: Show, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Show>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.showsUpdate(id, show, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShowsApi - factory interface
 * @export
 */
export const ShowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShowsApiFp(configuration)
    return {
        /**
         * 
         * @param {Show} show 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsCreate(show: Show, options?: any): AxiosPromise<Show> {
            return localVarFp.showsCreate(show, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.showsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsList(options?: any): AxiosPromise<Array<Show>> {
            return localVarFp.showsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {PatchedShow} [patchedShow] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsPartialUpdate(id: number, patchedShow?: PatchedShow, options?: any): AxiosPromise<Show> {
            return localVarFp.showsPartialUpdate(id, patchedShow, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsRetrieve(id: number, options?: any): AxiosPromise<Show> {
            return localVarFp.showsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this show.
         * @param {Show} show 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showsUpdate(id: number, show: Show, options?: any): AxiosPromise<Show> {
            return localVarFp.showsUpdate(id, show, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShowsApi - object-oriented interface
 * @export
 * @class ShowsApi
 * @extends {BaseAPI}
 */
export class ShowsApi extends BaseAPI {
    /**
     * 
     * @param {Show} show 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowsApi
     */
    public showsCreate(show: Show, options?: AxiosRequestConfig) {
        return ShowsApiFp(this.configuration).showsCreate(show, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowsApi
     */
    public showsDestroy(id: number, options?: AxiosRequestConfig) {
        return ShowsApiFp(this.configuration).showsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowsApi
     */
    public showsList(options?: AxiosRequestConfig) {
        return ShowsApiFp(this.configuration).showsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show.
     * @param {PatchedShow} [patchedShow] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowsApi
     */
    public showsPartialUpdate(id: number, patchedShow?: PatchedShow, options?: AxiosRequestConfig) {
        return ShowsApiFp(this.configuration).showsPartialUpdate(id, patchedShow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowsApi
     */
    public showsRetrieve(id: number, options?: AxiosRequestConfig) {
        return ShowsApiFp(this.configuration).showsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this show.
     * @param {Show} show 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShowsApi
     */
    public showsUpdate(id: number, show: Show, options?: AxiosRequestConfig) {
        return ShowsApiFp(this.configuration).showsUpdate(id, show, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SmartBlockContentsApi - axios parameter creator
 * @export
 */
export const SmartBlockContentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SmartBlockContent} smartBlockContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsCreate: async (smartBlockContent: SmartBlockContent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartBlockContent' is not null or undefined
            assertParamExists('smartBlockContentsCreate', 'smartBlockContent', smartBlockContent)
            const localVarPath = `/api/v2/smart-block-contents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartBlockContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlockContentsDestroy', 'id', id)
            const localVarPath = `/api/v2/smart-block-contents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/smart-block-contents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {PatchedSmartBlockContent} [patchedSmartBlockContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsPartialUpdate: async (id: number, patchedSmartBlockContent?: PatchedSmartBlockContent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlockContentsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/smart-block-contents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSmartBlockContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlockContentsRetrieve', 'id', id)
            const localVarPath = `/api/v2/smart-block-contents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {SmartBlockContent} smartBlockContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsUpdate: async (id: number, smartBlockContent: SmartBlockContent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlockContentsUpdate', 'id', id)
            // verify required parameter 'smartBlockContent' is not null or undefined
            assertParamExists('smartBlockContentsUpdate', 'smartBlockContent', smartBlockContent)
            const localVarPath = `/api/v2/smart-block-contents/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartBlockContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SmartBlockContentsApi - functional programming interface
 * @export
 */
export const SmartBlockContentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SmartBlockContentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SmartBlockContent} smartBlockContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockContentsCreate(smartBlockContent: SmartBlockContent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlockContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockContentsCreate(smartBlockContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockContentsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockContentsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockContentsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SmartBlockContent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockContentsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {PatchedSmartBlockContent} [patchedSmartBlockContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockContentsPartialUpdate(id: number, patchedSmartBlockContent?: PatchedSmartBlockContent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlockContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockContentsPartialUpdate(id, patchedSmartBlockContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockContentsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlockContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockContentsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {SmartBlockContent} smartBlockContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockContentsUpdate(id: number, smartBlockContent: SmartBlockContent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlockContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockContentsUpdate(id, smartBlockContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SmartBlockContentsApi - factory interface
 * @export
 */
export const SmartBlockContentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SmartBlockContentsApiFp(configuration)
    return {
        /**
         * 
         * @param {SmartBlockContent} smartBlockContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsCreate(smartBlockContent: SmartBlockContent, options?: any): AxiosPromise<SmartBlockContent> {
            return localVarFp.smartBlockContentsCreate(smartBlockContent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.smartBlockContentsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsList(options?: any): AxiosPromise<Array<SmartBlockContent>> {
            return localVarFp.smartBlockContentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {PatchedSmartBlockContent} [patchedSmartBlockContent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsPartialUpdate(id: number, patchedSmartBlockContent?: PatchedSmartBlockContent, options?: any): AxiosPromise<SmartBlockContent> {
            return localVarFp.smartBlockContentsPartialUpdate(id, patchedSmartBlockContent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsRetrieve(id: number, options?: any): AxiosPromise<SmartBlockContent> {
            return localVarFp.smartBlockContentsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block content.
         * @param {SmartBlockContent} smartBlockContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockContentsUpdate(id: number, smartBlockContent: SmartBlockContent, options?: any): AxiosPromise<SmartBlockContent> {
            return localVarFp.smartBlockContentsUpdate(id, smartBlockContent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SmartBlockContentsApi - object-oriented interface
 * @export
 * @class SmartBlockContentsApi
 * @extends {BaseAPI}
 */
export class SmartBlockContentsApi extends BaseAPI {
    /**
     * 
     * @param {SmartBlockContent} smartBlockContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockContentsApi
     */
    public smartBlockContentsCreate(smartBlockContent: SmartBlockContent, options?: AxiosRequestConfig) {
        return SmartBlockContentsApiFp(this.configuration).smartBlockContentsCreate(smartBlockContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockContentsApi
     */
    public smartBlockContentsDestroy(id: number, options?: AxiosRequestConfig) {
        return SmartBlockContentsApiFp(this.configuration).smartBlockContentsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockContentsApi
     */
    public smartBlockContentsList(options?: AxiosRequestConfig) {
        return SmartBlockContentsApiFp(this.configuration).smartBlockContentsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block content.
     * @param {PatchedSmartBlockContent} [patchedSmartBlockContent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockContentsApi
     */
    public smartBlockContentsPartialUpdate(id: number, patchedSmartBlockContent?: PatchedSmartBlockContent, options?: AxiosRequestConfig) {
        return SmartBlockContentsApiFp(this.configuration).smartBlockContentsPartialUpdate(id, patchedSmartBlockContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockContentsApi
     */
    public smartBlockContentsRetrieve(id: number, options?: AxiosRequestConfig) {
        return SmartBlockContentsApiFp(this.configuration).smartBlockContentsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block content.
     * @param {SmartBlockContent} smartBlockContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockContentsApi
     */
    public smartBlockContentsUpdate(id: number, smartBlockContent: SmartBlockContent, options?: AxiosRequestConfig) {
        return SmartBlockContentsApiFp(this.configuration).smartBlockContentsUpdate(id, smartBlockContent, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SmartBlockCriteriaApi - axios parameter creator
 * @export
 */
export const SmartBlockCriteriaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SmartBlockCriteria} smartBlockCriteria 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaCreate: async (smartBlockCriteria: SmartBlockCriteria, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartBlockCriteria' is not null or undefined
            assertParamExists('smartBlockCriteriaCreate', 'smartBlockCriteria', smartBlockCriteria)
            const localVarPath = `/api/v2/smart-block-criteria/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartBlockCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlockCriteriaDestroy', 'id', id)
            const localVarPath = `/api/v2/smart-block-criteria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/smart-block-criteria/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {PatchedSmartBlockCriteria} [patchedSmartBlockCriteria] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaPartialUpdate: async (id: number, patchedSmartBlockCriteria?: PatchedSmartBlockCriteria, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlockCriteriaPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/smart-block-criteria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSmartBlockCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlockCriteriaRetrieve', 'id', id)
            const localVarPath = `/api/v2/smart-block-criteria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {SmartBlockCriteria} smartBlockCriteria 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaUpdate: async (id: number, smartBlockCriteria: SmartBlockCriteria, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlockCriteriaUpdate', 'id', id)
            // verify required parameter 'smartBlockCriteria' is not null or undefined
            assertParamExists('smartBlockCriteriaUpdate', 'smartBlockCriteria', smartBlockCriteria)
            const localVarPath = `/api/v2/smart-block-criteria/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartBlockCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SmartBlockCriteriaApi - functional programming interface
 * @export
 */
export const SmartBlockCriteriaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SmartBlockCriteriaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SmartBlockCriteria} smartBlockCriteria 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockCriteriaCreate(smartBlockCriteria: SmartBlockCriteria, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlockCriteria>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockCriteriaCreate(smartBlockCriteria, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockCriteriaDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockCriteriaDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockCriteriaList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SmartBlockCriteria>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockCriteriaList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {PatchedSmartBlockCriteria} [patchedSmartBlockCriteria] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockCriteriaPartialUpdate(id: number, patchedSmartBlockCriteria?: PatchedSmartBlockCriteria, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlockCriteria>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockCriteriaPartialUpdate(id, patchedSmartBlockCriteria, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockCriteriaRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlockCriteria>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockCriteriaRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {SmartBlockCriteria} smartBlockCriteria 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlockCriteriaUpdate(id: number, smartBlockCriteria: SmartBlockCriteria, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlockCriteria>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlockCriteriaUpdate(id, smartBlockCriteria, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SmartBlockCriteriaApi - factory interface
 * @export
 */
export const SmartBlockCriteriaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SmartBlockCriteriaApiFp(configuration)
    return {
        /**
         * 
         * @param {SmartBlockCriteria} smartBlockCriteria 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaCreate(smartBlockCriteria: SmartBlockCriteria, options?: any): AxiosPromise<SmartBlockCriteria> {
            return localVarFp.smartBlockCriteriaCreate(smartBlockCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.smartBlockCriteriaDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaList(options?: any): AxiosPromise<Array<SmartBlockCriteria>> {
            return localVarFp.smartBlockCriteriaList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {PatchedSmartBlockCriteria} [patchedSmartBlockCriteria] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaPartialUpdate(id: number, patchedSmartBlockCriteria?: PatchedSmartBlockCriteria, options?: any): AxiosPromise<SmartBlockCriteria> {
            return localVarFp.smartBlockCriteriaPartialUpdate(id, patchedSmartBlockCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaRetrieve(id: number, options?: any): AxiosPromise<SmartBlockCriteria> {
            return localVarFp.smartBlockCriteriaRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block criteria.
         * @param {SmartBlockCriteria} smartBlockCriteria 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlockCriteriaUpdate(id: number, smartBlockCriteria: SmartBlockCriteria, options?: any): AxiosPromise<SmartBlockCriteria> {
            return localVarFp.smartBlockCriteriaUpdate(id, smartBlockCriteria, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SmartBlockCriteriaApi - object-oriented interface
 * @export
 * @class SmartBlockCriteriaApi
 * @extends {BaseAPI}
 */
export class SmartBlockCriteriaApi extends BaseAPI {
    /**
     * 
     * @param {SmartBlockCriteria} smartBlockCriteria 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockCriteriaApi
     */
    public smartBlockCriteriaCreate(smartBlockCriteria: SmartBlockCriteria, options?: AxiosRequestConfig) {
        return SmartBlockCriteriaApiFp(this.configuration).smartBlockCriteriaCreate(smartBlockCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block criteria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockCriteriaApi
     */
    public smartBlockCriteriaDestroy(id: number, options?: AxiosRequestConfig) {
        return SmartBlockCriteriaApiFp(this.configuration).smartBlockCriteriaDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockCriteriaApi
     */
    public smartBlockCriteriaList(options?: AxiosRequestConfig) {
        return SmartBlockCriteriaApiFp(this.configuration).smartBlockCriteriaList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block criteria.
     * @param {PatchedSmartBlockCriteria} [patchedSmartBlockCriteria] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockCriteriaApi
     */
    public smartBlockCriteriaPartialUpdate(id: number, patchedSmartBlockCriteria?: PatchedSmartBlockCriteria, options?: AxiosRequestConfig) {
        return SmartBlockCriteriaApiFp(this.configuration).smartBlockCriteriaPartialUpdate(id, patchedSmartBlockCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block criteria.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockCriteriaApi
     */
    public smartBlockCriteriaRetrieve(id: number, options?: AxiosRequestConfig) {
        return SmartBlockCriteriaApiFp(this.configuration).smartBlockCriteriaRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block criteria.
     * @param {SmartBlockCriteria} smartBlockCriteria 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlockCriteriaApi
     */
    public smartBlockCriteriaUpdate(id: number, smartBlockCriteria: SmartBlockCriteria, options?: AxiosRequestConfig) {
        return SmartBlockCriteriaApiFp(this.configuration).smartBlockCriteriaUpdate(id, smartBlockCriteria, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SmartBlocksApi - axios parameter creator
 * @export
 */
export const SmartBlocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SmartBlock} smartBlock 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksCreate: async (smartBlock: SmartBlock, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartBlock' is not null or undefined
            assertParamExists('smartBlocksCreate', 'smartBlock', smartBlock)
            const localVarPath = `/api/v2/smart-blocks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartBlock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlocksDestroy', 'id', id)
            const localVarPath = `/api/v2/smart-blocks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/smart-blocks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {PatchedSmartBlock} [patchedSmartBlock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksPartialUpdate: async (id: number, patchedSmartBlock?: PatchedSmartBlock, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlocksPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/smart-blocks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSmartBlock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlocksRetrieve', 'id', id)
            const localVarPath = `/api/v2/smart-blocks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {SmartBlock} smartBlock 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksUpdate: async (id: number, smartBlock: SmartBlock, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('smartBlocksUpdate', 'id', id)
            // verify required parameter 'smartBlock' is not null or undefined
            assertParamExists('smartBlocksUpdate', 'smartBlock', smartBlock)
            const localVarPath = `/api/v2/smart-blocks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartBlock, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SmartBlocksApi - functional programming interface
 * @export
 */
export const SmartBlocksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SmartBlocksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SmartBlock} smartBlock 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlocksCreate(smartBlock: SmartBlock, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlock>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlocksCreate(smartBlock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlocksDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlocksDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlocksList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SmartBlock>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlocksList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {PatchedSmartBlock} [patchedSmartBlock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlocksPartialUpdate(id: number, patchedSmartBlock?: PatchedSmartBlock, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlock>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlocksPartialUpdate(id, patchedSmartBlock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlocksRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlock>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlocksRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {SmartBlock} smartBlock 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async smartBlocksUpdate(id: number, smartBlock: SmartBlock, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartBlock>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.smartBlocksUpdate(id, smartBlock, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SmartBlocksApi - factory interface
 * @export
 */
export const SmartBlocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SmartBlocksApiFp(configuration)
    return {
        /**
         * 
         * @param {SmartBlock} smartBlock 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksCreate(smartBlock: SmartBlock, options?: any): AxiosPromise<SmartBlock> {
            return localVarFp.smartBlocksCreate(smartBlock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.smartBlocksDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksList(options?: any): AxiosPromise<Array<SmartBlock>> {
            return localVarFp.smartBlocksList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {PatchedSmartBlock} [patchedSmartBlock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksPartialUpdate(id: number, patchedSmartBlock?: PatchedSmartBlock, options?: any): AxiosPromise<SmartBlock> {
            return localVarFp.smartBlocksPartialUpdate(id, patchedSmartBlock, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksRetrieve(id: number, options?: any): AxiosPromise<SmartBlock> {
            return localVarFp.smartBlocksRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this smart block.
         * @param {SmartBlock} smartBlock 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        smartBlocksUpdate(id: number, smartBlock: SmartBlock, options?: any): AxiosPromise<SmartBlock> {
            return localVarFp.smartBlocksUpdate(id, smartBlock, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SmartBlocksApi - object-oriented interface
 * @export
 * @class SmartBlocksApi
 * @extends {BaseAPI}
 */
export class SmartBlocksApi extends BaseAPI {
    /**
     * 
     * @param {SmartBlock} smartBlock 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlocksApi
     */
    public smartBlocksCreate(smartBlock: SmartBlock, options?: AxiosRequestConfig) {
        return SmartBlocksApiFp(this.configuration).smartBlocksCreate(smartBlock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlocksApi
     */
    public smartBlocksDestroy(id: number, options?: AxiosRequestConfig) {
        return SmartBlocksApiFp(this.configuration).smartBlocksDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlocksApi
     */
    public smartBlocksList(options?: AxiosRequestConfig) {
        return SmartBlocksApiFp(this.configuration).smartBlocksList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block.
     * @param {PatchedSmartBlock} [patchedSmartBlock] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlocksApi
     */
    public smartBlocksPartialUpdate(id: number, patchedSmartBlock?: PatchedSmartBlock, options?: AxiosRequestConfig) {
        return SmartBlocksApiFp(this.configuration).smartBlocksPartialUpdate(id, patchedSmartBlock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlocksApi
     */
    public smartBlocksRetrieve(id: number, options?: AxiosRequestConfig) {
        return SmartBlocksApiFp(this.configuration).smartBlocksRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this smart block.
     * @param {SmartBlock} smartBlock 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SmartBlocksApi
     */
    public smartBlocksUpdate(id: number, smartBlock: SmartBlock, options?: AxiosRequestConfig) {
        return SmartBlocksApiFp(this.configuration).smartBlocksUpdate(id, smartBlock, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StationPodcastsApi - axios parameter creator
 * @export
 */
export const StationPodcastsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {StationPodcast} stationPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsCreate: async (stationPodcast: StationPodcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stationPodcast' is not null or undefined
            assertParamExists('stationPodcastsCreate', 'stationPodcast', stationPodcast)
            const localVarPath = `/api/v2/station-podcasts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stationPodcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stationPodcastsDestroy', 'id', id)
            const localVarPath = `/api/v2/station-podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/station-podcasts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {PatchedStationPodcast} [patchedStationPodcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsPartialUpdate: async (id: number, patchedStationPodcast?: PatchedStationPodcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stationPodcastsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/station-podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStationPodcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stationPodcastsRetrieve', 'id', id)
            const localVarPath = `/api/v2/station-podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {StationPodcast} stationPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsUpdate: async (id: number, stationPodcast: StationPodcast, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('stationPodcastsUpdate', 'id', id)
            // verify required parameter 'stationPodcast' is not null or undefined
            assertParamExists('stationPodcastsUpdate', 'stationPodcast', stationPodcast)
            const localVarPath = `/api/v2/station-podcasts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stationPodcast, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StationPodcastsApi - functional programming interface
 * @export
 */
export const StationPodcastsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StationPodcastsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {StationPodcast} stationPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stationPodcastsCreate(stationPodcast: StationPodcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StationPodcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stationPodcastsCreate(stationPodcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stationPodcastsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stationPodcastsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stationPodcastsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StationPodcast>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stationPodcastsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {PatchedStationPodcast} [patchedStationPodcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stationPodcastsPartialUpdate(id: number, patchedStationPodcast?: PatchedStationPodcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StationPodcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stationPodcastsPartialUpdate(id, patchedStationPodcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stationPodcastsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StationPodcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stationPodcastsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {StationPodcast} stationPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stationPodcastsUpdate(id: number, stationPodcast: StationPodcast, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StationPodcast>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stationPodcastsUpdate(id, stationPodcast, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StationPodcastsApi - factory interface
 * @export
 */
export const StationPodcastsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StationPodcastsApiFp(configuration)
    return {
        /**
         * 
         * @param {StationPodcast} stationPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsCreate(stationPodcast: StationPodcast, options?: any): AxiosPromise<StationPodcast> {
            return localVarFp.stationPodcastsCreate(stationPodcast, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.stationPodcastsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsList(options?: any): AxiosPromise<Array<StationPodcast>> {
            return localVarFp.stationPodcastsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {PatchedStationPodcast} [patchedStationPodcast] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsPartialUpdate(id: number, patchedStationPodcast?: PatchedStationPodcast, options?: any): AxiosPromise<StationPodcast> {
            return localVarFp.stationPodcastsPartialUpdate(id, patchedStationPodcast, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsRetrieve(id: number, options?: any): AxiosPromise<StationPodcast> {
            return localVarFp.stationPodcastsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this station podcast.
         * @param {StationPodcast} stationPodcast 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stationPodcastsUpdate(id: number, stationPodcast: StationPodcast, options?: any): AxiosPromise<StationPodcast> {
            return localVarFp.stationPodcastsUpdate(id, stationPodcast, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StationPodcastsApi - object-oriented interface
 * @export
 * @class StationPodcastsApi
 * @extends {BaseAPI}
 */
export class StationPodcastsApi extends BaseAPI {
    /**
     * 
     * @param {StationPodcast} stationPodcast 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationPodcastsApi
     */
    public stationPodcastsCreate(stationPodcast: StationPodcast, options?: AxiosRequestConfig) {
        return StationPodcastsApiFp(this.configuration).stationPodcastsCreate(stationPodcast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this station podcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationPodcastsApi
     */
    public stationPodcastsDestroy(id: number, options?: AxiosRequestConfig) {
        return StationPodcastsApiFp(this.configuration).stationPodcastsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationPodcastsApi
     */
    public stationPodcastsList(options?: AxiosRequestConfig) {
        return StationPodcastsApiFp(this.configuration).stationPodcastsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this station podcast.
     * @param {PatchedStationPodcast} [patchedStationPodcast] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationPodcastsApi
     */
    public stationPodcastsPartialUpdate(id: number, patchedStationPodcast?: PatchedStationPodcast, options?: AxiosRequestConfig) {
        return StationPodcastsApiFp(this.configuration).stationPodcastsPartialUpdate(id, patchedStationPodcast, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this station podcast.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationPodcastsApi
     */
    public stationPodcastsRetrieve(id: number, options?: AxiosRequestConfig) {
        return StationPodcastsApiFp(this.configuration).stationPodcastsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this station podcast.
     * @param {StationPodcast} stationPodcast 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StationPodcastsApi
     */
    public stationPodcastsUpdate(id: number, stationPodcast: StationPodcast, options?: AxiosRequestConfig) {
        return StationPodcastsApiFp(this.configuration).stationPodcastsUpdate(id, stationPodcast, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StreamSettingsApi - axios parameter creator
 * @export
 */
export const StreamSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {StreamSetting} streamSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsCreate: async (streamSetting: StreamSetting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'streamSetting' is not null or undefined
            assertParamExists('streamSettingsCreate', 'streamSetting', streamSetting)
            const localVarPath = `/api/v2/stream-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(streamSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsDestroy: async (keyname: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyname' is not null or undefined
            assertParamExists('streamSettingsDestroy', 'keyname', keyname)
            const localVarPath = `/api/v2/stream-settings/{keyname}/`
                .replace(`{${"keyname"}}`, encodeURIComponent(String(keyname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/stream-settings/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {PatchedStreamSetting} [patchedStreamSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsPartialUpdate: async (keyname: string, patchedStreamSetting?: PatchedStreamSetting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyname' is not null or undefined
            assertParamExists('streamSettingsPartialUpdate', 'keyname', keyname)
            const localVarPath = `/api/v2/stream-settings/{keyname}/`
                .replace(`{${"keyname"}}`, encodeURIComponent(String(keyname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStreamSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsRetrieve: async (keyname: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyname' is not null or undefined
            assertParamExists('streamSettingsRetrieve', 'keyname', keyname)
            const localVarPath = `/api/v2/stream-settings/{keyname}/`
                .replace(`{${"keyname"}}`, encodeURIComponent(String(keyname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {StreamSetting} streamSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsUpdate: async (keyname: string, streamSetting: StreamSetting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyname' is not null or undefined
            assertParamExists('streamSettingsUpdate', 'keyname', keyname)
            // verify required parameter 'streamSetting' is not null or undefined
            assertParamExists('streamSettingsUpdate', 'streamSetting', streamSetting)
            const localVarPath = `/api/v2/stream-settings/{keyname}/`
                .replace(`{${"keyname"}}`, encodeURIComponent(String(keyname)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(streamSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamSettingsApi - functional programming interface
 * @export
 */
export const StreamSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StreamSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {StreamSetting} streamSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamSettingsCreate(streamSetting: StreamSetting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamSettingsCreate(streamSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamSettingsDestroy(keyname: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamSettingsDestroy(keyname, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamSettingsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StreamSetting>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamSettingsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {PatchedStreamSetting} [patchedStreamSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamSettingsPartialUpdate(keyname: string, patchedStreamSetting?: PatchedStreamSetting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamSettingsPartialUpdate(keyname, patchedStreamSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamSettingsRetrieve(keyname: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamSettingsRetrieve(keyname, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {StreamSetting} streamSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async streamSettingsUpdate(keyname: string, streamSetting: StreamSetting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.streamSettingsUpdate(keyname, streamSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StreamSettingsApi - factory interface
 * @export
 */
export const StreamSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StreamSettingsApiFp(configuration)
    return {
        /**
         * 
         * @param {StreamSetting} streamSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsCreate(streamSetting: StreamSetting, options?: any): AxiosPromise<StreamSetting> {
            return localVarFp.streamSettingsCreate(streamSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsDestroy(keyname: string, options?: any): AxiosPromise<void> {
            return localVarFp.streamSettingsDestroy(keyname, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsList(options?: any): AxiosPromise<Array<StreamSetting>> {
            return localVarFp.streamSettingsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {PatchedStreamSetting} [patchedStreamSetting] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsPartialUpdate(keyname: string, patchedStreamSetting?: PatchedStreamSetting, options?: any): AxiosPromise<StreamSetting> {
            return localVarFp.streamSettingsPartialUpdate(keyname, patchedStreamSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsRetrieve(keyname: string, options?: any): AxiosPromise<StreamSetting> {
            return localVarFp.streamSettingsRetrieve(keyname, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} keyname A unique value identifying this stream setting.
         * @param {StreamSetting} streamSetting 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        streamSettingsUpdate(keyname: string, streamSetting: StreamSetting, options?: any): AxiosPromise<StreamSetting> {
            return localVarFp.streamSettingsUpdate(keyname, streamSetting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreamSettingsApi - object-oriented interface
 * @export
 * @class StreamSettingsApi
 * @extends {BaseAPI}
 */
export class StreamSettingsApi extends BaseAPI {
    /**
     * 
     * @param {StreamSetting} streamSetting 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamSettingsApi
     */
    public streamSettingsCreate(streamSetting: StreamSetting, options?: AxiosRequestConfig) {
        return StreamSettingsApiFp(this.configuration).streamSettingsCreate(streamSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} keyname A unique value identifying this stream setting.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamSettingsApi
     */
    public streamSettingsDestroy(keyname: string, options?: AxiosRequestConfig) {
        return StreamSettingsApiFp(this.configuration).streamSettingsDestroy(keyname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamSettingsApi
     */
    public streamSettingsList(options?: AxiosRequestConfig) {
        return StreamSettingsApiFp(this.configuration).streamSettingsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} keyname A unique value identifying this stream setting.
     * @param {PatchedStreamSetting} [patchedStreamSetting] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamSettingsApi
     */
    public streamSettingsPartialUpdate(keyname: string, patchedStreamSetting?: PatchedStreamSetting, options?: AxiosRequestConfig) {
        return StreamSettingsApiFp(this.configuration).streamSettingsPartialUpdate(keyname, patchedStreamSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} keyname A unique value identifying this stream setting.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamSettingsApi
     */
    public streamSettingsRetrieve(keyname: string, options?: AxiosRequestConfig) {
        return StreamSettingsApiFp(this.configuration).streamSettingsRetrieve(keyname, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} keyname A unique value identifying this stream setting.
     * @param {StreamSetting} streamSetting 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamSettingsApi
     */
    public streamSettingsUpdate(keyname: string, streamSetting: StreamSetting, options?: AxiosRequestConfig) {
        return StreamSettingsApiFp(this.configuration).streamSettingsUpdate(keyname, streamSetting, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ThirdPartyTrackReferencesApi - axios parameter creator
 * @export
 */
export const ThirdPartyTrackReferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ThirdPartyTrackReference} thirdPartyTrackReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesCreate: async (thirdPartyTrackReference: ThirdPartyTrackReference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'thirdPartyTrackReference' is not null or undefined
            assertParamExists('thirdPartyTrackReferencesCreate', 'thirdPartyTrackReference', thirdPartyTrackReference)
            const localVarPath = `/api/v2/third-party-track-references/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(thirdPartyTrackReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('thirdPartyTrackReferencesDestroy', 'id', id)
            const localVarPath = `/api/v2/third-party-track-references/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/third-party-track-references/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {PatchedThirdPartyTrackReference} [patchedThirdPartyTrackReference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesPartialUpdate: async (id: number, patchedThirdPartyTrackReference?: PatchedThirdPartyTrackReference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('thirdPartyTrackReferencesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/third-party-track-references/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedThirdPartyTrackReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('thirdPartyTrackReferencesRetrieve', 'id', id)
            const localVarPath = `/api/v2/third-party-track-references/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {ThirdPartyTrackReference} thirdPartyTrackReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesUpdate: async (id: number, thirdPartyTrackReference: ThirdPartyTrackReference, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('thirdPartyTrackReferencesUpdate', 'id', id)
            // verify required parameter 'thirdPartyTrackReference' is not null or undefined
            assertParamExists('thirdPartyTrackReferencesUpdate', 'thirdPartyTrackReference', thirdPartyTrackReference)
            const localVarPath = `/api/v2/third-party-track-references/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(thirdPartyTrackReference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThirdPartyTrackReferencesApi - functional programming interface
 * @export
 */
export const ThirdPartyTrackReferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThirdPartyTrackReferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ThirdPartyTrackReference} thirdPartyTrackReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thirdPartyTrackReferencesCreate(thirdPartyTrackReference: ThirdPartyTrackReference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThirdPartyTrackReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thirdPartyTrackReferencesCreate(thirdPartyTrackReference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thirdPartyTrackReferencesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thirdPartyTrackReferencesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thirdPartyTrackReferencesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThirdPartyTrackReference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thirdPartyTrackReferencesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {PatchedThirdPartyTrackReference} [patchedThirdPartyTrackReference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thirdPartyTrackReferencesPartialUpdate(id: number, patchedThirdPartyTrackReference?: PatchedThirdPartyTrackReference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThirdPartyTrackReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thirdPartyTrackReferencesPartialUpdate(id, patchedThirdPartyTrackReference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thirdPartyTrackReferencesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThirdPartyTrackReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thirdPartyTrackReferencesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {ThirdPartyTrackReference} thirdPartyTrackReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async thirdPartyTrackReferencesUpdate(id: number, thirdPartyTrackReference: ThirdPartyTrackReference, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ThirdPartyTrackReference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.thirdPartyTrackReferencesUpdate(id, thirdPartyTrackReference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ThirdPartyTrackReferencesApi - factory interface
 * @export
 */
export const ThirdPartyTrackReferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThirdPartyTrackReferencesApiFp(configuration)
    return {
        /**
         * 
         * @param {ThirdPartyTrackReference} thirdPartyTrackReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesCreate(thirdPartyTrackReference: ThirdPartyTrackReference, options?: any): AxiosPromise<ThirdPartyTrackReference> {
            return localVarFp.thirdPartyTrackReferencesCreate(thirdPartyTrackReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.thirdPartyTrackReferencesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesList(options?: any): AxiosPromise<Array<ThirdPartyTrackReference>> {
            return localVarFp.thirdPartyTrackReferencesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {PatchedThirdPartyTrackReference} [patchedThirdPartyTrackReference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesPartialUpdate(id: number, patchedThirdPartyTrackReference?: PatchedThirdPartyTrackReference, options?: any): AxiosPromise<ThirdPartyTrackReference> {
            return localVarFp.thirdPartyTrackReferencesPartialUpdate(id, patchedThirdPartyTrackReference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesRetrieve(id: number, options?: any): AxiosPromise<ThirdPartyTrackReference> {
            return localVarFp.thirdPartyTrackReferencesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this third party track reference.
         * @param {ThirdPartyTrackReference} thirdPartyTrackReference 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        thirdPartyTrackReferencesUpdate(id: number, thirdPartyTrackReference: ThirdPartyTrackReference, options?: any): AxiosPromise<ThirdPartyTrackReference> {
            return localVarFp.thirdPartyTrackReferencesUpdate(id, thirdPartyTrackReference, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThirdPartyTrackReferencesApi - object-oriented interface
 * @export
 * @class ThirdPartyTrackReferencesApi
 * @extends {BaseAPI}
 */
export class ThirdPartyTrackReferencesApi extends BaseAPI {
    /**
     * 
     * @param {ThirdPartyTrackReference} thirdPartyTrackReference 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdPartyTrackReferencesApi
     */
    public thirdPartyTrackReferencesCreate(thirdPartyTrackReference: ThirdPartyTrackReference, options?: AxiosRequestConfig) {
        return ThirdPartyTrackReferencesApiFp(this.configuration).thirdPartyTrackReferencesCreate(thirdPartyTrackReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this third party track reference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdPartyTrackReferencesApi
     */
    public thirdPartyTrackReferencesDestroy(id: number, options?: AxiosRequestConfig) {
        return ThirdPartyTrackReferencesApiFp(this.configuration).thirdPartyTrackReferencesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdPartyTrackReferencesApi
     */
    public thirdPartyTrackReferencesList(options?: AxiosRequestConfig) {
        return ThirdPartyTrackReferencesApiFp(this.configuration).thirdPartyTrackReferencesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this third party track reference.
     * @param {PatchedThirdPartyTrackReference} [patchedThirdPartyTrackReference] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdPartyTrackReferencesApi
     */
    public thirdPartyTrackReferencesPartialUpdate(id: number, patchedThirdPartyTrackReference?: PatchedThirdPartyTrackReference, options?: AxiosRequestConfig) {
        return ThirdPartyTrackReferencesApiFp(this.configuration).thirdPartyTrackReferencesPartialUpdate(id, patchedThirdPartyTrackReference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this third party track reference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdPartyTrackReferencesApi
     */
    public thirdPartyTrackReferencesRetrieve(id: number, options?: AxiosRequestConfig) {
        return ThirdPartyTrackReferencesApiFp(this.configuration).thirdPartyTrackReferencesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this third party track reference.
     * @param {ThirdPartyTrackReference} thirdPartyTrackReference 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdPartyTrackReferencesApi
     */
    public thirdPartyTrackReferencesUpdate(id: number, thirdPartyTrackReference: ThirdPartyTrackReference, options?: AxiosRequestConfig) {
        return ThirdPartyTrackReferencesApiFp(this.configuration).thirdPartyTrackReferencesUpdate(id, thirdPartyTrackReference, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TimestampsApi - axios parameter creator
 * @export
 */
export const TimestampsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Timestamp} timestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsCreate: async (timestamp: Timestamp, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('timestampsCreate', 'timestamp', timestamp)
            const localVarPath = `/api/v2/timestamps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timestamp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('timestampsDestroy', 'id', id)
            const localVarPath = `/api/v2/timestamps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/timestamps/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {PatchedTimestamp} [patchedTimestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsPartialUpdate: async (id: number, patchedTimestamp?: PatchedTimestamp, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('timestampsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/timestamps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTimestamp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('timestampsRetrieve', 'id', id)
            const localVarPath = `/api/v2/timestamps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {Timestamp} timestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsUpdate: async (id: number, timestamp: Timestamp, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('timestampsUpdate', 'id', id)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('timestampsUpdate', 'timestamp', timestamp)
            const localVarPath = `/api/v2/timestamps/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(timestamp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimestampsApi - functional programming interface
 * @export
 */
export const TimestampsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimestampsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Timestamp} timestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timestampsCreate(timestamp: Timestamp, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Timestamp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timestampsCreate(timestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timestampsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timestampsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timestampsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Timestamp>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timestampsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {PatchedTimestamp} [patchedTimestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timestampsPartialUpdate(id: number, patchedTimestamp?: PatchedTimestamp, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Timestamp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timestampsPartialUpdate(id, patchedTimestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timestampsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Timestamp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timestampsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {Timestamp} timestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timestampsUpdate(id: number, timestamp: Timestamp, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Timestamp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timestampsUpdate(id, timestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimestampsApi - factory interface
 * @export
 */
export const TimestampsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimestampsApiFp(configuration)
    return {
        /**
         * 
         * @param {Timestamp} timestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsCreate(timestamp: Timestamp, options?: any): AxiosPromise<Timestamp> {
            return localVarFp.timestampsCreate(timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.timestampsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsList(options?: any): AxiosPromise<Array<Timestamp>> {
            return localVarFp.timestampsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {PatchedTimestamp} [patchedTimestamp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsPartialUpdate(id: number, patchedTimestamp?: PatchedTimestamp, options?: any): AxiosPromise<Timestamp> {
            return localVarFp.timestampsPartialUpdate(id, patchedTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsRetrieve(id: number, options?: any): AxiosPromise<Timestamp> {
            return localVarFp.timestampsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this timestamp.
         * @param {Timestamp} timestamp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timestampsUpdate(id: number, timestamp: Timestamp, options?: any): AxiosPromise<Timestamp> {
            return localVarFp.timestampsUpdate(id, timestamp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TimestampsApi - object-oriented interface
 * @export
 * @class TimestampsApi
 * @extends {BaseAPI}
 */
export class TimestampsApi extends BaseAPI {
    /**
     * 
     * @param {Timestamp} timestamp 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimestampsApi
     */
    public timestampsCreate(timestamp: Timestamp, options?: AxiosRequestConfig) {
        return TimestampsApiFp(this.configuration).timestampsCreate(timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimestampsApi
     */
    public timestampsDestroy(id: number, options?: AxiosRequestConfig) {
        return TimestampsApiFp(this.configuration).timestampsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimestampsApi
     */
    public timestampsList(options?: AxiosRequestConfig) {
        return TimestampsApiFp(this.configuration).timestampsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this timestamp.
     * @param {PatchedTimestamp} [patchedTimestamp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimestampsApi
     */
    public timestampsPartialUpdate(id: number, patchedTimestamp?: PatchedTimestamp, options?: AxiosRequestConfig) {
        return TimestampsApiFp(this.configuration).timestampsPartialUpdate(id, patchedTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this timestamp.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimestampsApi
     */
    public timestampsRetrieve(id: number, options?: AxiosRequestConfig) {
        return TimestampsApiFp(this.configuration).timestampsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this timestamp.
     * @param {Timestamp} timestamp 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimestampsApi
     */
    public timestampsUpdate(id: number, timestamp: Timestamp, options?: AxiosRequestConfig) {
        return TimestampsApiFp(this.configuration).timestampsUpdate(id, timestamp, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrackTypesApi - axios parameter creator
 * @export
 */
export const TrackTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TrackType} trackType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesCreate: async (trackType: TrackType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackType' is not null or undefined
            assertParamExists('trackTypesCreate', 'trackType', trackType)
            const localVarPath = `/api/v2/track-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trackTypesDestroy', 'id', id)
            const localVarPath = `/api/v2/track-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/track-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {PatchedTrackType} [patchedTrackType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesPartialUpdate: async (id: number, patchedTrackType?: PatchedTrackType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trackTypesPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/track-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTrackType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trackTypesRetrieve', 'id', id)
            const localVarPath = `/api/v2/track-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {TrackType} trackType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesUpdate: async (id: number, trackType: TrackType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trackTypesUpdate', 'id', id)
            // verify required parameter 'trackType' is not null or undefined
            assertParamExists('trackTypesUpdate', 'trackType', trackType)
            const localVarPath = `/api/v2/track-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trackType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrackTypesApi - functional programming interface
 * @export
 */
export const TrackTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrackTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TrackType} trackType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackTypesCreate(trackType: TrackType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackTypesCreate(trackType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackTypesDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackTypesDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackTypesList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackTypesList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {PatchedTrackType} [patchedTrackType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackTypesPartialUpdate(id: number, patchedTrackType?: PatchedTrackType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackTypesPartialUpdate(id, patchedTrackType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackTypesRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackTypesRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {TrackType} trackType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trackTypesUpdate(id: number, trackType: TrackType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trackTypesUpdate(id, trackType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrackTypesApi - factory interface
 * @export
 */
export const TrackTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrackTypesApiFp(configuration)
    return {
        /**
         * 
         * @param {TrackType} trackType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesCreate(trackType: TrackType, options?: any): AxiosPromise<TrackType> {
            return localVarFp.trackTypesCreate(trackType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.trackTypesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesList(options?: any): AxiosPromise<Array<TrackType>> {
            return localVarFp.trackTypesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {PatchedTrackType} [patchedTrackType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesPartialUpdate(id: number, patchedTrackType?: PatchedTrackType, options?: any): AxiosPromise<TrackType> {
            return localVarFp.trackTypesPartialUpdate(id, patchedTrackType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesRetrieve(id: number, options?: any): AxiosPromise<TrackType> {
            return localVarFp.trackTypesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this track type.
         * @param {TrackType} trackType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trackTypesUpdate(id: number, trackType: TrackType, options?: any): AxiosPromise<TrackType> {
            return localVarFp.trackTypesUpdate(id, trackType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrackTypesApi - object-oriented interface
 * @export
 * @class TrackTypesApi
 * @extends {BaseAPI}
 */
export class TrackTypesApi extends BaseAPI {
    /**
     * 
     * @param {TrackType} trackType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackTypesApi
     */
    public trackTypesCreate(trackType: TrackType, options?: AxiosRequestConfig) {
        return TrackTypesApiFp(this.configuration).trackTypesCreate(trackType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this track type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackTypesApi
     */
    public trackTypesDestroy(id: number, options?: AxiosRequestConfig) {
        return TrackTypesApiFp(this.configuration).trackTypesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackTypesApi
     */
    public trackTypesList(options?: AxiosRequestConfig) {
        return TrackTypesApiFp(this.configuration).trackTypesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this track type.
     * @param {PatchedTrackType} [patchedTrackType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackTypesApi
     */
    public trackTypesPartialUpdate(id: number, patchedTrackType?: PatchedTrackType, options?: AxiosRequestConfig) {
        return TrackTypesApiFp(this.configuration).trackTypesPartialUpdate(id, patchedTrackType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this track type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackTypesApi
     */
    public trackTypesRetrieve(id: number, options?: AxiosRequestConfig) {
        return TrackTypesApiFp(this.configuration).trackTypesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this track type.
     * @param {TrackType} trackType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrackTypesApi
     */
    public trackTypesUpdate(id: number, trackType: TrackType, options?: AxiosRequestConfig) {
        return TrackTypesApiFp(this.configuration).trackTypesUpdate(id, trackType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserTokensApi - axios parameter creator
 * @export
 */
export const UserTokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserToken} userToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensCreate: async (userToken: UserToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('userTokensCreate', 'userToken', userToken)
            const localVarPath = `/api/v2/user-tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userTokensDestroy', 'id', id)
            const localVarPath = `/api/v2/user-tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/user-tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {PatchedUserToken} [patchedUserToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensPartialUpdate: async (id: number, patchedUserToken?: PatchedUserToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userTokensPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/user-tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userTokensRetrieve', 'id', id)
            const localVarPath = `/api/v2/user-tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {UserToken} userToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensUpdate: async (id: number, userToken: UserToken, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userTokensUpdate', 'id', id)
            // verify required parameter 'userToken' is not null or undefined
            assertParamExists('userTokensUpdate', 'userToken', userToken)
            const localVarPath = `/api/v2/user-tokens/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserTokensApi - functional programming interface
 * @export
 */
export const UserTokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserTokensApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UserToken} userToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTokensCreate(userToken: UserToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTokensCreate(userToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTokensDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTokensDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTokensList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTokensList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {PatchedUserToken} [patchedUserToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTokensPartialUpdate(id: number, patchedUserToken?: PatchedUserToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTokensPartialUpdate(id, patchedUserToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTokensRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTokensRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {UserToken} userToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userTokensUpdate(id: number, userToken: UserToken, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userTokensUpdate(id, userToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserTokensApi - factory interface
 * @export
 */
export const UserTokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserTokensApiFp(configuration)
    return {
        /**
         * 
         * @param {UserToken} userToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensCreate(userToken: UserToken, options?: any): AxiosPromise<UserToken> {
            return localVarFp.userTokensCreate(userToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userTokensDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensList(options?: any): AxiosPromise<Array<UserToken>> {
            return localVarFp.userTokensList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {PatchedUserToken} [patchedUserToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensPartialUpdate(id: number, patchedUserToken?: PatchedUserToken, options?: any): AxiosPromise<UserToken> {
            return localVarFp.userTokensPartialUpdate(id, patchedUserToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensRetrieve(id: number, options?: any): AxiosPromise<UserToken> {
            return localVarFp.userTokensRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user token.
         * @param {UserToken} userToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userTokensUpdate(id: number, userToken: UserToken, options?: any): AxiosPromise<UserToken> {
            return localVarFp.userTokensUpdate(id, userToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserTokensApi - object-oriented interface
 * @export
 * @class UserTokensApi
 * @extends {BaseAPI}
 */
export class UserTokensApi extends BaseAPI {
    /**
     * 
     * @param {UserToken} userToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokensApi
     */
    public userTokensCreate(userToken: UserToken, options?: AxiosRequestConfig) {
        return UserTokensApiFp(this.configuration).userTokensCreate(userToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokensApi
     */
    public userTokensDestroy(id: number, options?: AxiosRequestConfig) {
        return UserTokensApiFp(this.configuration).userTokensDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokensApi
     */
    public userTokensList(options?: AxiosRequestConfig) {
        return UserTokensApiFp(this.configuration).userTokensList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user token.
     * @param {PatchedUserToken} [patchedUserToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokensApi
     */
    public userTokensPartialUpdate(id: number, patchedUserToken?: PatchedUserToken, options?: AxiosRequestConfig) {
        return UserTokensApiFp(this.configuration).userTokensPartialUpdate(id, patchedUserToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokensApi
     */
    public userTokensRetrieve(id: number, options?: AxiosRequestConfig) {
        return UserTokensApiFp(this.configuration).userTokensRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user token.
     * @param {UserToken} userToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTokensApi
     */
    public userTokensUpdate(id: number, userToken: UserToken, options?: AxiosRequestConfig) {
        return UserTokensApiFp(this.configuration).userTokensUpdate(id, userToken, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCreate', 'user', user)
            const localVarPath = `/api/v2/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDestroy', 'id', id)
            const localVarPath = `/api/v2/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (id: number, patchedUser?: PatchedUser, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRetrieve', 'id', id)
            const localVarPath = `/api/v2/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: number, user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersUpdate', 'user', user)
            const localVarPath = `/api/v2/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreate(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(id, patchedUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: number, user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.usersCreate(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.usersList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersPartialUpdate(id, patchedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.usersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: number, user: User, options?: any): AxiosPromise<User> {
            return localVarFp.usersUpdate(id, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreate(user: User, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCreate(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDestroy(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersList(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUser} [patchedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPartialUpdate(id, patchedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(id: number, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: number, user: User, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdate(id, user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionRetrieve: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/version/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionRetrieve(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.versionRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public versionRetrieve(options?: AxiosRequestConfig) {
        return VersionApiFp(this.configuration).versionRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebstreamMetadataApi - axios parameter creator
 * @export
 */
export const WebstreamMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {WebstreamMetadata} webstreamMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataCreate: async (webstreamMetadata: WebstreamMetadata, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webstreamMetadata' is not null or undefined
            assertParamExists('webstreamMetadataCreate', 'webstreamMetadata', webstreamMetadata)
            const localVarPath = `/api/v2/webstream-metadata/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webstreamMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webstreamMetadataDestroy', 'id', id)
            const localVarPath = `/api/v2/webstream-metadata/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/webstream-metadata/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {PatchedWebstreamMetadata} [patchedWebstreamMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataPartialUpdate: async (id: number, patchedWebstreamMetadata?: PatchedWebstreamMetadata, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webstreamMetadataPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/webstream-metadata/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWebstreamMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webstreamMetadataRetrieve', 'id', id)
            const localVarPath = `/api/v2/webstream-metadata/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {WebstreamMetadata} webstreamMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataUpdate: async (id: number, webstreamMetadata: WebstreamMetadata, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webstreamMetadataUpdate', 'id', id)
            // verify required parameter 'webstreamMetadata' is not null or undefined
            assertParamExists('webstreamMetadataUpdate', 'webstreamMetadata', webstreamMetadata)
            const localVarPath = `/api/v2/webstream-metadata/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webstreamMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebstreamMetadataApi - functional programming interface
 * @export
 */
export const WebstreamMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebstreamMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {WebstreamMetadata} webstreamMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamMetadataCreate(webstreamMetadata: WebstreamMetadata, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebstreamMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamMetadataCreate(webstreamMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamMetadataDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamMetadataDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamMetadataList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebstreamMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamMetadataList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {PatchedWebstreamMetadata} [patchedWebstreamMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamMetadataPartialUpdate(id: number, patchedWebstreamMetadata?: PatchedWebstreamMetadata, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebstreamMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamMetadataPartialUpdate(id, patchedWebstreamMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamMetadataRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebstreamMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamMetadataRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {WebstreamMetadata} webstreamMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamMetadataUpdate(id: number, webstreamMetadata: WebstreamMetadata, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebstreamMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamMetadataUpdate(id, webstreamMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebstreamMetadataApi - factory interface
 * @export
 */
export const WebstreamMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebstreamMetadataApiFp(configuration)
    return {
        /**
         * 
         * @param {WebstreamMetadata} webstreamMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataCreate(webstreamMetadata: WebstreamMetadata, options?: any): AxiosPromise<WebstreamMetadata> {
            return localVarFp.webstreamMetadataCreate(webstreamMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.webstreamMetadataDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataList(options?: any): AxiosPromise<Array<WebstreamMetadata>> {
            return localVarFp.webstreamMetadataList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {PatchedWebstreamMetadata} [patchedWebstreamMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataPartialUpdate(id: number, patchedWebstreamMetadata?: PatchedWebstreamMetadata, options?: any): AxiosPromise<WebstreamMetadata> {
            return localVarFp.webstreamMetadataPartialUpdate(id, patchedWebstreamMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataRetrieve(id: number, options?: any): AxiosPromise<WebstreamMetadata> {
            return localVarFp.webstreamMetadataRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream metadata.
         * @param {WebstreamMetadata} webstreamMetadata 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamMetadataUpdate(id: number, webstreamMetadata: WebstreamMetadata, options?: any): AxiosPromise<WebstreamMetadata> {
            return localVarFp.webstreamMetadataUpdate(id, webstreamMetadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebstreamMetadataApi - object-oriented interface
 * @export
 * @class WebstreamMetadataApi
 * @extends {BaseAPI}
 */
export class WebstreamMetadataApi extends BaseAPI {
    /**
     * 
     * @param {WebstreamMetadata} webstreamMetadata 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamMetadataApi
     */
    public webstreamMetadataCreate(webstreamMetadata: WebstreamMetadata, options?: AxiosRequestConfig) {
        return WebstreamMetadataApiFp(this.configuration).webstreamMetadataCreate(webstreamMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webstream metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamMetadataApi
     */
    public webstreamMetadataDestroy(id: number, options?: AxiosRequestConfig) {
        return WebstreamMetadataApiFp(this.configuration).webstreamMetadataDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamMetadataApi
     */
    public webstreamMetadataList(options?: AxiosRequestConfig) {
        return WebstreamMetadataApiFp(this.configuration).webstreamMetadataList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webstream metadata.
     * @param {PatchedWebstreamMetadata} [patchedWebstreamMetadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamMetadataApi
     */
    public webstreamMetadataPartialUpdate(id: number, patchedWebstreamMetadata?: PatchedWebstreamMetadata, options?: AxiosRequestConfig) {
        return WebstreamMetadataApiFp(this.configuration).webstreamMetadataPartialUpdate(id, patchedWebstreamMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webstream metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamMetadataApi
     */
    public webstreamMetadataRetrieve(id: number, options?: AxiosRequestConfig) {
        return WebstreamMetadataApiFp(this.configuration).webstreamMetadataRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webstream metadata.
     * @param {WebstreamMetadata} webstreamMetadata 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamMetadataApi
     */
    public webstreamMetadataUpdate(id: number, webstreamMetadata: WebstreamMetadata, options?: AxiosRequestConfig) {
        return WebstreamMetadataApiFp(this.configuration).webstreamMetadataUpdate(id, webstreamMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebstreamsApi - axios parameter creator
 * @export
 */
export const WebstreamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Webstream} webstream 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsCreate: async (webstream: Webstream, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webstream' is not null or undefined
            assertParamExists('webstreamsCreate', 'webstream', webstream)
            const localVarPath = `/api/v2/webstreams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webstream, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsDestroy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webstreamsDestroy', 'id', id)
            const localVarPath = `/api/v2/webstreams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/webstreams/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {PatchedWebstream} [patchedWebstream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsPartialUpdate: async (id: number, patchedWebstream?: PatchedWebstream, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webstreamsPartialUpdate', 'id', id)
            const localVarPath = `/api/v2/webstreams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedWebstream, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsRetrieve: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webstreamsRetrieve', 'id', id)
            const localVarPath = `/api/v2/webstreams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {Webstream} webstream 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsUpdate: async (id: number, webstream: Webstream, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('webstreamsUpdate', 'id', id)
            // verify required parameter 'webstream' is not null or undefined
            assertParamExists('webstreamsUpdate', 'webstream', webstream)
            const localVarPath = `/api/v2/webstreams/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication cookieAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webstream, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebstreamsApi - functional programming interface
 * @export
 */
export const WebstreamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebstreamsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Webstream} webstream 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamsCreate(webstream: Webstream, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webstream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamsCreate(webstream, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamsDestroy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamsDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamsList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Webstream>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {PatchedWebstream} [patchedWebstream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamsPartialUpdate(id: number, patchedWebstream?: PatchedWebstream, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webstream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamsPartialUpdate(id, patchedWebstream, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamsRetrieve(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webstream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamsRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {Webstream} webstream 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webstreamsUpdate(id: number, webstream: Webstream, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Webstream>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webstreamsUpdate(id, webstream, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebstreamsApi - factory interface
 * @export
 */
export const WebstreamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebstreamsApiFp(configuration)
    return {
        /**
         * 
         * @param {Webstream} webstream 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsCreate(webstream: Webstream, options?: any): AxiosPromise<Webstream> {
            return localVarFp.webstreamsCreate(webstream, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.webstreamsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsList(options?: any): AxiosPromise<Array<Webstream>> {
            return localVarFp.webstreamsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {PatchedWebstream} [patchedWebstream] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsPartialUpdate(id: number, patchedWebstream?: PatchedWebstream, options?: any): AxiosPromise<Webstream> {
            return localVarFp.webstreamsPartialUpdate(id, patchedWebstream, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsRetrieve(id: number, options?: any): AxiosPromise<Webstream> {
            return localVarFp.webstreamsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this webstream.
         * @param {Webstream} webstream 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webstreamsUpdate(id: number, webstream: Webstream, options?: any): AxiosPromise<Webstream> {
            return localVarFp.webstreamsUpdate(id, webstream, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebstreamsApi - object-oriented interface
 * @export
 * @class WebstreamsApi
 * @extends {BaseAPI}
 */
export class WebstreamsApi extends BaseAPI {
    /**
     * 
     * @param {Webstream} webstream 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamsApi
     */
    public webstreamsCreate(webstream: Webstream, options?: AxiosRequestConfig) {
        return WebstreamsApiFp(this.configuration).webstreamsCreate(webstream, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webstream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamsApi
     */
    public webstreamsDestroy(id: number, options?: AxiosRequestConfig) {
        return WebstreamsApiFp(this.configuration).webstreamsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamsApi
     */
    public webstreamsList(options?: AxiosRequestConfig) {
        return WebstreamsApiFp(this.configuration).webstreamsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webstream.
     * @param {PatchedWebstream} [patchedWebstream] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamsApi
     */
    public webstreamsPartialUpdate(id: number, patchedWebstream?: PatchedWebstream, options?: AxiosRequestConfig) {
        return WebstreamsApiFp(this.configuration).webstreamsPartialUpdate(id, patchedWebstream, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webstream.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamsApi
     */
    public webstreamsRetrieve(id: number, options?: AxiosRequestConfig) {
        return WebstreamsApiFp(this.configuration).webstreamsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this webstream.
     * @param {Webstream} webstream 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebstreamsApi
     */
    public webstreamsUpdate(id: number, webstream: Webstream, options?: AxiosRequestConfig) {
        return WebstreamsApiFp(this.configuration).webstreamsUpdate(id, webstream, options).then((request) => request(this.axios, this.basePath));
    }
}


